<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>LambdaBlog: lambda is not a four letter word</title>
        <link>https://thma.github.io/</link>
        <description><![CDATA[This feed lists the latest blog posts]]></description>
        <atom:link href="https://thma.github.io//rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Fri, 15 Aug 2025 00:00:00 UT</lastBuildDate>
        <item>
    <title>Embedding MicroHs</title>
    <link>https://thma.github.io//posts/2025-08-15-Embedding-MicroHs.html</link>
    <description><![CDATA[<div class="info">
    <em>Posted on August 15, 2025
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<p><a href="https://github.com/thma/lambda-ski"><img src="https://thma.github.io/img/forkme.png" height="20" ></a></p>
<h2 id="abstract">Abstract</h2>
<p>This post shows how to embed Lennart Augustsson’s MicroHs—a compact, bootstrappable Haskell based on combinatory logic—as a backend for an experimental compiler. It covers generating MicroHs‑compatible combinator expressions, emitting the out.comb format, and executing the result with the MicroHs runtime. Benchmarks demonstrate substantial speedups over a custom graph‑reduction engine. The post also outlines contributions that expose MicroHs as an embeddable library and FFI wrapper, enabling compilation and execution from GHC programs and making embedded graph reduction practical in larger applications.</p>
<h2 id="introduction">Introduction</h2>
<p>Attentive readers of my blog will have noticed that I am a big fan of combinatory logic and graph reduction in the implementation of functional languages.</p>
<p>Some time ago, I became aware of <a href="https://github.com/augustss/MicroHs?tab=readme-ov-file#micro-haskell">Lennart Augustsson’s MicroHs project</a>, which provides an alternative Haskell compiler that targets a runtime environment based on combinatory logic and graph reduction.</p>
<p>MicroHs is an awesome project for several reasons:</p>
<ul>
<li><p>It demonstrates how a complex high-level language like Haskell can be translated and executed efficiently using bracket abstraction, Scott encoding, combinatory logic and a graph reduction runtime.</p></li>
<li><p>It outlines an approach for bootstrapping a Haskell compiler using only a C compiler as a prerequisite. This represents a significant step for bootstrapping the GHC compiler in the sense of the <a href="https://www.bootstrappable.org/projects.html">Bootstrappable project</a>.</p></li>
<li><p>The entire codebase remains compact and “hackable”, making it an ideal textbook example for a functional language compiler.</p></li>
</ul>
<p>While studying the MicroHs codebase I noticed that it uses compilation techniques, combinatory logic expressions and graph reduction mechanics that are quite close to the concepts that I presented in <a href="#appendix-my-earlier-posts-on-combinatory-logic-and-graph-reduction">some of my previous blog posts on this topic</a>. I was particularly impressed by the MicroHs graph-reduction runtime implemented in C.</p>
<p>So I came up with the idea of adjusting my toy compilation system to generate object code that can be executed with the MicroHs runtime system.</p>
<p>In this blog post I’ll explain what I did to achieve this goal. I’ll also explain briefly the two pull requests that I added to MicroHs, which allow to embed MicroHs into Haskell code copiled with GHC.</p>
<h2 id="using-the-microhs-runtime-as-a-backend-for-my-toy-compiler">Using the MicroHs Runtime as a backend for my toy compiler</h2>
<p>MicroHs is using a set of combinators that is quite close to those used in my toy language implementation.</p>
<p>The only difference I noticed was in the handling of conditional expressions. My toy compiler was using a dedicated <code>IF</code> combinator, whereas MicroHs is providing a much more generic and flexible system that makes clever use of combinators <code>A</code> and <code>K</code>.</p>
<p>This gave me confidence that it shouldn’t be too difficult to use the MicroHs runtime as a target to my compiler.</p>
<h3 id="getting-rid-of-the-if-combinator">Getting rid of the IF combinator</h3>
<p>As my toy language is just dealing with functions over integers I tried to keep thngs as easy as possible and thus modelled <code>True</code> as <code>1</code> and <code>False</code> as <code>0</code>.
So for example in the <a href="https://github.com/thma/lambda-ski/blob/main/src/HhiReducer.hs">HhiReducer</a> the equality test <code>eql</code> is defined as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">eql ::</span> (<span class="dt">Eq</span> a, <span class="dt">Num</span> p) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> p</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>eql n m <span class="ot">=</span> <span class="kw">if</span> n <span class="op">==</span> m <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span></code></pre></div>
<p>The <code>IF</code>-Combinator takes three arguments <code>condition</code>, <code>thenExpr</code> and <code>elseExpr</code>. The semantics is simple: if <code>condition</code> evaluates to <code>1</code>, <code>thenExpr</code> is evaluated alse <code>elseExpr</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">CFun</span> (\(<span class="dt">CInt</span> condition) <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \thenExpr <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \elseExpr <span class="ot">-&gt;</span> </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> condition <span class="op">==</span> <span class="dv">1</span> </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> thenExpr </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> elseExpr)</span></code></pre></div>
<p>MicroHs is encoding boolean values quite differently:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span> <span class="ot">=</span> <span class="dt">A</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">False</span> <span class="ot">=</span> <span class="dt">K</span></span></code></pre></div>
<p>Where <code>A</code> and <code>K</code> are Combinators defined as follows:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">K</span> x y <span class="ot">=</span> x </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">A</span> x y <span class="ot">=</span> y</span></code></pre></div>
<p>So in this Encoding <code>True</code> and <code>False</code> can be used as selector functions to either pick the <code>thenExpr</code> or the <code>elseExpr</code> for evaluation.</p>
<p>We can apply this feature to eliminate the <code>IF</code>-combinator. We will achieve this by using a new function <code>desugarIf</code> before performing bracket abstraction. This function will desugar <code>If</code>-expressions to Scott encoded boolean applications. It will detect sourcecode patterns <code>if condition thenExpr elseExpr</code> and transforms it to: <code>condition elseExpr thenExpr</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">desugarIf ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>desugarIf (((<span class="dt">Var</span> <span class="st">&quot;if&quot;</span> <span class="ot">`App`</span> condition) <span class="ot">`App`</span> thenExpr) <span class="ot">`App`</span> elseExpr) <span class="ot">=</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  (desugarIf condition <span class="ot">`App`</span> desugarIf elseExpr) <span class="ot">`App`</span> desugarIf thenExpr</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>desugarIf (<span class="dt">App</span> e1 e2) <span class="ot">=</span> <span class="dt">App</span> (desugarIf e1) (desugarIf e2)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>desugarIf (<span class="dt">Lam</span> x e) <span class="ot">=</span> <span class="dt">Lam</span> x (desugarIf e)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>desugarIf expr <span class="ot">=</span> expr  <span class="co">-- Var, Int remain unchanged</span></span></code></pre></div>
<p>When <code>condition</code> evaluates to <code>True</code> (i.e. <code>A</code>) the second argument (<code>thenExpr</code>) will be selected.
When <code>condition</code>evaluates to <code>False</code> (i.e. <code>K</code>) the first argument (<code>elseExpr</code>) will be selected.</p>
<p>To make this work we will have to change all comparison functions to return <code>A</code>and <code>K</code>, like in the following snippet from the HhiReducer:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">eql ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">CExpr</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>eql n m <span class="ot">=</span> <span class="kw">if</span> n <span class="op">==</span> m <span class="kw">then</span> trueCExpr <span class="kw">else</span> falseCExpr</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Helper functions for Scott-encoded booleans</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="ot">trueCExpr ::</span> <span class="dt">CExpr</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>trueCExpr <span class="ot">=</span> link primitives (translate (<span class="dt">Com</span> <span class="dt">A</span>))</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="ot">falseCExpr ::</span> <span class="dt">CExpr</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>falseCExpr <span class="ot">=</span> link primitives (translate (<span class="dt">Com</span> <span class="dt">K</span>))</span></code></pre></div>
<p>Let’s have a closer look how this can be very handy when compiling conditional expressions to efficient code. Let’s illustrate this with an example of my improved toy compiler. Let’s say we have a very simple <code>main</code>-expression:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">Int</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">if</span> (eql <span class="dv">0</span> <span class="dv">1</span>) <span class="dv">23</span> <span class="dv">42</span></span></code></pre></div>
<p>With the new desugaring this will compiled to the following combinator expression. Please note that <code>thenExpr</code> and <code>elseExpr</code> have been swapped by <code>desugarIf</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">EQL</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">42</span> <span class="dv">23</span></span></code></pre></div>
<p>Now let`s have a look at the combinator-reduction of this expression:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">EQL</span> <span class="dv">0</span> <span class="dv">1</span> <span class="dv">42</span> <span class="dv">23</span> </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">K</span> <span class="dv">42</span> <span class="dv">23</span><span class="op">.</span>       <span class="co">-- by reducing EQL 0 1 to K (representing &#39;False&#39;)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="dv">42</span>             <span class="co">-- by reducing K x y to x</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- likewise for the &#39;True&#39; case:</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="dt">EQL</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">42</span> <span class="dv">23</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="dt">A</span> <span class="dv">42</span> <span class="dv">23</span><span class="op">.</span>       <span class="co">-- by reducing EQL 0 0 to A (representing &#39;True&#39;)</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="dv">23</span>             <span class="co">-- by reducing A x y to y</span></span></code></pre></div>
<h3 id="producing-microhs-compatible-combinator-code-from-my-toy-compiler">producing MicroHs compatible combinator code from my toy compiler</h3>
<p>After fixing the incompatibility in the handling of conditional expressions there is is only one task left: We’ll have to translate the combinator expressions generated by my compiler to a valid MicroHs combinator program. This is done in the <a href="https://github.com/thma/lambda-ski/blob/main/src/MicroHsExp.hs">MicroHsExp</a> module.</p>
<p>The first step is to map from my <code>CLTerm.CL</code>-terms to <code>MicroHs.Exp</code>-terms.
By looking at the type definitions we can see that the mapping will be straightforward:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- CLTerm.CL:</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">CL</span> <span class="ot">=</span> </span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Com</span> <span class="dt">Combinator</span> </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">INT</span> <span class="dt">Integer</span> </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">CL</span> <span class="op">:@</span> <span class="dt">CL</span> </span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Data</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- MicroHs.Exp:</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Exp</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Ident</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Exp</span> <span class="dt">Exp</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Ident</span> <span class="dt">Exp</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lit</span> <span class="dt">Lit</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>)  </span></code></pre></div>
<p>The <code>Exp</code> data type is used to store desugared λ-Terms as well as combinator terms. That is the reason why it allows free variables (<code>Var</code>) and λ-terms (<code>Lam</code>). But after running bracket abstraction over such a term it will only <code>App</code> and <code>Lit</code> constructors.</p>
<p>With this knowledge we can define a <code>toMhsExp :: CL -&gt; Exp</code> function:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">CLTerm</span> (<span class="dt">CL</span>(..))</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">MicroHs.Exp</span> (<span class="dt">Exp</span>(..))</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">MicroHs.Expr</span> (<span class="dt">Lit</span>(..))</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="ot">toMhsExp ::</span> <span class="dt">CL</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>toMhsExp (<span class="dt">Com</span> c) <span class="ot">=</span> <span class="dt">Lit</span> (<span class="dt">LPrim</span> (combToMhscomb c))</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>toMhsExp (<span class="dt">INT</span> i) <span class="ot">=</span> <span class="dt">Lit</span> (<span class="dt">LInt</span> (<span class="fu">fromIntegral</span> i))     <span class="co">-- LInt only works with Int</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>toMhsExp (t <span class="op">:@</span> u) <span class="ot">=</span> <span class="dt">App</span> (toMhsExp t) (toMhsExp u)</span></code></pre></div>
<p>The interesting part here is that both integers and combinators are treated as <code>Lit</code> instances with specific constructors <code>LInt</code> and <code>LPrim</code>.</p>
<p>In order to be able to import MicroHs code I contributed a PR which exposes the MicroHs source code as a library in the <a href="https://github.com/augustss/MicroHs/blob/master/MicroHs.cabal">MicroHs.cabal</a> file. Now we can simply embed the MicroHs compiler (or parts of it) in any Haskell program by adding <code>MicroHs</code>as a dependency to our <code>.cabal</code> or <code>package.yaml</code> files.</p>
<p>Mapping the combinators and primops of my compiler to MicroHs can simply be achieved by <code>show</code>, only for a few arithmetic and comparison primops we need specific translations as MicroHs uses <a href="https://github.com/augustss/MicroHs/blob/master/ghc/PrimTable.hs#L32">other names for them</a>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">CLTerm</span> (<span class="dt">Combinator</span>(..))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="ot">combToMhscomb ::</span> <span class="dt">Combinator</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>combToMhscomb <span class="dt">ADD</span> <span class="ot">=</span> <span class="st">&quot;+&quot;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>combToMhscomb <span class="dt">SUB</span> <span class="ot">=</span> <span class="st">&quot;-&quot;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>combToMhscomb <span class="dt">MUL</span> <span class="ot">=</span> <span class="st">&quot;*&quot;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>combToMhscomb <span class="dt">DIV</span> <span class="ot">=</span> <span class="st">&quot;/&quot;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>combToMhscomb <span class="dt">REM</span> <span class="ot">=</span> <span class="st">&quot;rem&quot;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>combToMhscomb <span class="dt">EQL</span> <span class="ot">=</span> <span class="st">&quot;==&quot;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>combToMhscomb <span class="dt">GEQ</span> <span class="ot">=</span> <span class="st">&quot;&gt;=&quot;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>combToMhscomb c <span class="ot">=</span> <span class="fu">show</span> c</span></code></pre></div>
<h3 id="translating-my-combinator-expressions-into-mhs-out.comb-format">translating my combinator expressions into MHS out.comb format</h3>
<p>The final step of producing a valid MicroHs <code>out.comb</code> file is even simpler.
MicroHs defines a function <code>toStringCMdl</code>, which takes a list of definitions (i.e. all functions, expressions and CAFs defined in a haskell program) and an expression representing the <code>main</code>-expression of a Haskell program as input. The result is a tuple with the number of definitions, a list of all foreign export identifiers, and the program as a string. This last element of the tuple will contain the contain the actual combinator code, i.e. the contents of an <code>out.comb</code>file.</p>
<p>Even when compiling a program with many top-level definitions my toy compiler just returns the compiled <code>main</code> expression (with all calls to other toplevel definitions expanded to combinator code). As we we don’t have any top-level definitions left after compilation we just hand over an empty list</p>
<p>With this knowledge we can can compile our <code>CL</code>-term to a valid MicroHs program with very little effort:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">MicroHs.ExpPrint</span> (toStringCMdl)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="ot">toMhsPrg ::</span> <span class="dt">CL</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>toMhsPrg cl <span class="ot">=</span> </span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    definitions <span class="ot">=</span> [] </span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    (n, exps, prg) <span class="ot">=</span> toStringCMdl (definitions, toMhsExp cl)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> prg</span></code></pre></div>
<h3 id="a-first-test-drive">A first test drive</h3>
<p>Now it’s time for a first test drive of our solution:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorial ::</span> <span class="dt">String</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>factorial <span class="ot">=</span> [r| </span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  fact = y(\f n. if (eql n 0) 1 (* n (f (- n 1))))</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  main = fact 10</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>|]</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> source <span class="ot">=</span> factorial</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>      env <span class="ot">=</span> parseEnvironment source</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>      expr&#39; <span class="ot">=</span> compileEta env<span class="op">.</span>  <span class="co">-- compileEta is a good default for dense combinator code</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>      prg <span class="ot">=</span> toMhsPrg expr&#39;     <span class="co">-- use MicroHs.ExpPrint.toStringCMdl to produce MicroHs code    </span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Factorial compiled to combinator expression:\n&quot;</span> <span class="op">++</span> <span class="fu">show</span> expr&#39;</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;The resulting MicroHs program: \n&quot;</span> <span class="op">++</span> prg</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">writeFile</span> <span class="st">&quot;out.comb&quot;</span> prg<span class="op">.</span>    <span class="co">-- out.comb is the default file name for code executed by mhseval</span></span></code></pre></div>
<pre><code>ghci&gt; main
Factorial compiled to combinator expression: 
Y(R 1(B C(B(S(C EQL 0))(B(S MUL)(R(C SUB 1) B))))) 10
The resulting MicroHs program: 
v8.2
0
Y R #1 @B C @B S C == @#0 @@@B S * @@R C - @#1 @@B @@@@@@#10 @ }</code></pre>
<p>Please note that <code>Int</code> literals are encoded with a leading <code>#</code>in MicroHs code format, like <code>#0</code>, <code>#1</code>and <code>#10</code> in the program above.</p>
<p>Now we use the MicroHs evaluator <code>mhseval</code> to run this program written to the file <code>out.comb</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">bash</span><span class="op">&gt;</span> mhseval </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co">#3628800</span></span></code></pre></div>
<p>I think this is quite impressive: MicroHs knows all the combinators my toy compiler is emmitting, including the <code>Y</code>-combinator
and the reduction works in the expected way and produces the correct result!</p>
<p>So using the MicroHs evaluator as a runtime environment for combinator code generated by other compilers seems quite feasible!</p>
<h2 id="using-an-ffi-wrapper-to-call-mhseval-from-haskell">Using an FFI Wrapper to call <code>mhseval</code> from Haskell</h2>
<p>My intial idea was to use the benchmark suite presented in <a href="#appendix-my-earlier-posts-on-combinatory-logic-and-graph-reduction">my earlier posts</a> to find out how MicroHs compares to my toy implementations.</p>
<p>As a first attempt I encapsulated the generation of MicroHs code and calling <code>mhseval</code> like follows:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">microHsevalTest ::</span> <span class="dt">CL</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>microHsevalTest expr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> prg <span class="ot">=</span> toMhsPrg expr</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  readProcess <span class="st">&quot;mhseval&quot;</span> [] prg</span></code></pre></div>
<p>This worked, but due to the overhead caused by executing <code>mhseval</code> as an external process I did not see any performance gains.</p>
<p>So I came up with a new plan: let’s write an FFI wrapper around <code>mhseval</code> to avoid spawning external processes.</p>
<p>I won’t go into the details of this wrapper. The good news is that the respective PR was accepted and is now part of the official MicroHs codebase.
If you are interested you can study the code of the <code>C</code>-wrapper here: <a href="https://github.com/augustss/MicroHs/blob/master/src/runtime/mhseval.h">mhseval.h</a> and <a href="https://github.com/augustss/MicroHs/blob/master/src/runtime/mhseval.c">mhseval.c</a>.
The Haskell wrapper is in <a href="https://github.com/augustss/MicroHs/blob/master/ghc/MhsEval.hs">MhsEval.hs</a>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">MicroHsExp</span> (toMhsPrg)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">MhsEval</span> (withMhsContext, eval, run)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> source <span class="ot">=</span> factorial</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> env <span class="ot">=</span> parseEnvironment source</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> expr <span class="ot">=</span> compileEta env</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Factorial compiled to combinator expression:\n&quot;</span> <span class="op">++</span> <span class="fu">show</span> expr</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> prg <span class="ot">=</span> toMhsPrg expr</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;The resulting MicroHs program: \n&quot;</span> <span class="op">++</span> prg</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>  result <span class="ot">&lt;-</span> withMhsContext <span class="op">$</span> \ctx <span class="ot">-&gt;</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    eval ctx prg</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Result: &quot;</span> <span class="op">++</span> result</span></code></pre></div>
<p>The resulting output does not bring any surprises:</p>
<pre><code>ghci&gt; main
Factorial compiled to combinator expression: 
Y(R 1(B C(B(S(C EQL 0))(B(S MUL)(R(C SUB 1) B))))) 10
The resulting MicroHs program: 
v8.2
0
Y R #1 @B C @B S C == @#0 @@@B S * @@R C - @#1 @@B @@@@@@#10 @ }
Result: #3628800</code></pre>
<p>The function <code>withMhsContext :: (MhsContext -&gt; IO a) -&gt; IO a</code> executes an action (like <code>eval</code> or <code>run</code>) with a MicroHs context. It initializes a context, runs the action, and cleans up afterwards. It is useful for one-off evaluations without needing to manage the context manually.</p>
<p>The function <code>eval :: MhsContext -&gt; MhsCombCode -&gt; IO String</code> takes a string containing MicroHs combinator code, evaluates it, and returns the result as a string. If evaluation fails, it throws an <code>MhsEvalError</code>. The type <code>MhsCombCode</code> is just an alias for <code>String</code>. This currently works properly only for results of type <code>Int</code>.</p>
<p>The function <code>run :: MhsContext -&gt; MhsCombCode -&gt; IO ()</code> takes a string containing MicroHs combinator code, and runs it without returning any result.</p>
<p>In a scenario like a performance benchmark it is not a good idea to create a new context in the tight benchmark loop. For such use cases I have also provided functions for explicitely managing the context: <code>createMhsContext :: IO MhsContext</code> and <code>closeMhsContext :: MhsContext -&gt; IO ()</code>.</p>
<h2 id="benchmarking-mhseval-against-my-toy-runtime.">Benchmarking MhsEval against my toy runtime.</h2>
<p>In my <a href="https://thma.github.io/posts/2023-10-08-Optimizing-bracket-abstraction-for-combinator-reduction.html">last blog post on this matter</a> I focussed on comparing different bracket abstraction algorithms. This time I will have a closer look to execution speed of graph-reduction based approaches versus GHC compiled code.</p>
<p>I will consider three execution runtimes:</p>
<ul>
<li>The HHI-Reducer. This is the fastest of my graph-reduction implementations.</li>
<li>The MicroHs Runtime mhseval</li>
<li>The GHC Runtime</li>
</ul>
<p>As I am focussing on backend performance I will not vary the compilation algorithm. I will use the <code>compileEta</code> algorithm (introduced in the above mentioned post) which will produce the most compact combinator code for standard combinators. (As of now MicroHs does not support Bulk-Combinators which would allow even more compact code.)</p>
<p>I will benchmark execution of the following programs of my toy language:</p>
<h3 id="fibonacci">fibonacci</h3>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>fibonacci <span class="ot">=</span> [r| </span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  fib  = y(λf n. if (leq n 1) 1 (+ (f (- n 1)) (f (- n 2))))</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  main = fib 37</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>|]</span></code></pre></div>
<p>compiled by <code>compileEta</code> to:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Y</span>(<span class="dt">R</span> <span class="dv">1</span>(<span class="dt">B</span> <span class="dt">C</span>(<span class="dt">B</span>(<span class="dt">S</span>(<span class="dt">C</span> <span class="dt">LEQ</span> <span class="dv">1</span>))(<span class="dt">S</span>(<span class="dt">B</span> <span class="dt">S</span>(<span class="dt">B</span>(<span class="dt">B</span> <span class="dt">ADD</span>)(<span class="dt">R</span>(<span class="dt">C</span> <span class="dt">SUB</span> <span class="dv">1</span>) <span class="dt">B</span>)))(<span class="dt">R</span>(<span class="dt">C</span> <span class="dt">SUB</span> <span class="dv">2</span>) <span class="dt">B</span>))))) <span class="dv">37</span></span></code></pre></div>
<h3 id="ackermann">ackermann</h3>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>ackermann <span class="ot">=</span> [r|</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  ack  = y(λf n m. if (eql n 0) (+ m 1) (if (eql m 0) (f (- n 1) 1) (f (- n 1) (f n (- m 1)))))</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  main = ack 3 9</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>|]</span></code></pre></div>
<p>compiled to:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Y</span>(<span class="dt">B</span>(<span class="dt">R</span>(<span class="dt">C</span> <span class="dt">ADD</span> <span class="dv">1</span>))(<span class="dt">B</span>(<span class="dt">B</span> <span class="dt">S</span>)(<span class="dt">B</span>(<span class="dt">S</span>(<span class="dt">B</span> <span class="dt">B</span>(<span class="dt">R</span> <span class="dv">0</span> <span class="dt">EQL</span>)))(<span class="dt">S</span>(<span class="dt">B</span> <span class="dt">S</span>(<span class="dt">B</span>(<span class="dt">B</span> <span class="dt">C</span>)(<span class="dt">B</span>(<span class="dt">B</span>(<span class="dt">S</span>(<span class="dt">C</span> <span class="dt">EQL</span> <span class="dv">0</span>)))(<span class="dt">S</span>(<span class="dt">B</span> <span class="dt">S</span>(<span class="dt">B</span>(<span class="dt">B</span> <span class="dt">B</span>)(<span class="dt">R</span>(<span class="dt">R</span> <span class="dv">1</span> <span class="dt">SUB</span>) <span class="dt">B</span>)))(<span class="dt">B</span>(<span class="dt">R</span>(<span class="dt">C</span> <span class="dt">SUB</span> <span class="dv">1</span>))(<span class="dt">B</span> <span class="dt">B</span>))))))(<span class="dt">B</span>(<span class="dt">R</span> <span class="dv">1</span>)(<span class="dt">R</span>(<span class="dt">R</span> <span class="dv">1</span> <span class="dt">SUB</span>) <span class="dt">B</span>)))))) <span class="dv">3</span> <span class="dv">9</span></span></code></pre></div>
<h3 id="tak">tak</h3>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>tak <span class="ot">=</span> [r| </span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  tak  = y(λf x y z. (if (geq y x) z (f (f (- x 1) y z) (f (- y 1) z x) (f (- z 1) x y ))))</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  main = tak 18 6 3</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>|]</span></code></pre></div>
<p>compiled to:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Y</span>(<span class="dt">B</span>(<span class="dt">B</span>(<span class="dt">R</span> <span class="dt">I</span>))(<span class="dt">B</span>(<span class="dt">B</span>(<span class="dt">B</span> <span class="dt">S</span>))(<span class="dt">B</span>(<span class="dt">S</span>(<span class="dt">B</span> <span class="dt">S</span>(<span class="dt">B</span>(<span class="dt">B</span> <span class="dt">B</span>)(<span class="dt">C</span> <span class="dt">GEQ</span>))))(<span class="dt">S</span>(<span class="dt">B</span> <span class="dt">S</span>(<span class="dt">B</span>(<span class="dt">B</span> <span class="dt">S</span>)(<span class="dt">B</span>(<span class="dt">B</span>(<span class="dt">B</span> <span class="dt">S</span>))(<span class="dt">S</span>(<span class="dt">B</span> <span class="dt">S</span>(<span class="dt">B</span>(<span class="dt">B</span> <span class="dt">S</span>)(<span class="dt">B</span>(<span class="dt">B</span>(<span class="dt">B</span> <span class="dt">S</span>))(<span class="dt">S</span>(<span class="dt">B</span> <span class="dt">B</span>(<span class="dt">B</span> <span class="dt">B</span> <span class="dt">B</span>))(<span class="dt">R</span>(<span class="dt">R</span> <span class="dv">1</span> <span class="dt">SUB</span>) <span class="dt">B</span>)))))(<span class="dt">B</span> <span class="dt">C</span>(<span class="dt">B</span>(<span class="dt">B</span> <span class="dt">C</span>)(<span class="dt">R</span>(<span class="dt">R</span> <span class="dv">1</span> <span class="dt">SUB</span>) <span class="dt">B</span>)))))))(<span class="dt">B</span>(<span class="dt">B</span> <span class="dt">C</span>)(<span class="dt">B</span> <span class="dt">C</span>(<span class="dt">R</span>(<span class="dt">C</span> <span class="dt">SUB</span> <span class="dv">1</span>) <span class="dt">B</span>))))))) <span class="dv">18</span> <span class="dv">6</span> <span class="dv">3</span></span></code></pre></div>
<p>In order to compare these programs against GHC I’m using the following Haskell equivalents for GHC:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>fib  <span class="ot">=</span> fix (\f n <span class="ot">-&gt;</span> </span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span> </span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="dv">1</span> </span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> f (n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> f (n <span class="op">-</span> <span class="dv">2</span>))</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>ack  <span class="ot">=</span> fix (\f n m <span class="ot">-&gt;</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> m <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> (<span class="kw">if</span> m <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> f (n<span class="op">-</span><span class="dv">1</span>) <span class="dv">1</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> f (n<span class="op">-</span><span class="dv">1</span>) (f n (m<span class="op">-</span><span class="dv">1</span>))))</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>tak  <span class="ot">=</span> fix (\f x y z <span class="ot">-&gt;</span> </span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> y <span class="op">&gt;=</span> x </span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> z </span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> f (f (x<span class="op">-</span><span class="dv">1</span>) y z) (f (y<span class="op">-</span><span class="dv">1</span>) z x) (f (z<span class="op">-</span><span class="dv">1</span>) x y ))</span></code></pre></div>
<p>Benchmarking these programs with the <a href="https://hackage.haskell.org/package/criterion">Criterion micro-benchmarking suite</a> yields the following results:</p>
<table>
<thead>
<tr>
<th>program</th>
<th>HHI-Reducer</th>
<th>MicroHs</th>
<th>Haskell native</th>
</tr>
</thead>
<tbody>
<tr>
<td>fib 37</td>
<td>8.641 s</td>
<td>6.296 s</td>
<td>727.3 ms</td>
</tr>
<tr>
<td>ackermann 3 9</td>
<td>4.170 s</td>
<td>1.575 s</td>
<td>105.6 ms</td>
</tr>
<tr>
<td>tak 18 6 3</td>
<td>1.225 ms</td>
<td>1.101 ms</td>
<td>42.01 μs</td>
</tr>
</tbody>
</table>
<h3 id="interpretation-of-the-results">Interpretation of the results</h3>
<p>The numbers show a clear hierarchy: MicroHs consistently outperforms the baseline HHI-Reducer, but native GHC code remains an order of magnitude faster. There is some variation between the different programs. For example, MicroHs can handle the ack-function significantly better (factor 2.6) than the HHI-Reducer. For the tak-function on the other hand the factor is just 1.1. A complete overview is given in the following table:</p>
<table>
<thead>
<tr>
<th>factor in direct comparison</th>
<th>fib</th>
<th>ack</th>
<th>tak</th>
</tr>
</thead>
<tbody>
<tr>
<td>MicroHs vs HHI-Reducer</td>
<td>1.4</td>
<td>2.6</td>
<td>1.1</td>
</tr>
<tr>
<td>GHC native vs MicroHs</td>
<td>8.7</td>
<td>14.9</td>
<td>26.2</td>
</tr>
</tbody>
</table>
<p>Before doing this benchmarking exercise I had two expectations:</p>
<ul>
<li>MicroHs will outperform my toy reducers.</li>
<li>GHC will be about ten times faster then MicroHs.</li>
</ul>
<p>My first expection was met, however for a 3-argument function like <code>tak</code> MicroHs is only 10% faster.</p>
<p>The second expectation was clearly not met for the <code>tak</code>-function!
In my <a href="https://thma.github.io/posts/2023-10-08-Optimizing-bracket-abstraction-for-combinator-reduction.html">post on optimizing bracket abstraction</a> I have demonstrated how the code size of classic abstraction algorithms will grow quadratically with the number of variables of a function. In that post I have also shown how advanced approaches like <a href="https://okmij.org/ftp/tagless-final/ski.pdf">Kiselyovs Bulk-Combinators</a> can significantly improve this behaviour.</p>
<p>So evaluating if Bulk-combinators could improve performance of MicroHs would be an interesting topic.</p>
<p>Looking at the compilation output of the <code>fib 37</code> program, there seems to very little room for improvement as the generated code is already quite dense:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Y</span>(<span class="dt">R</span> <span class="dv">1</span>(<span class="dt">B</span> <span class="dt">C</span>(<span class="dt">B</span>(<span class="dt">S</span>(<span class="dt">C</span> <span class="dt">LEQ</span> <span class="dv">1</span>))(<span class="dt">S</span>(<span class="dt">B</span> <span class="dt">S</span>(<span class="dt">B</span>(<span class="dt">B</span> <span class="dt">ADD</span>)(<span class="dt">R</span>(<span class="dt">C</span> <span class="dt">SUB</span> <span class="dv">1</span>) <span class="dt">B</span>)))(<span class="dt">R</span>(<span class="dt">C</span> <span class="dt">SUB</span> <span class="dv">2</span>) <span class="dt">B</span>))))) <span class="dv">37</span></span></code></pre></div>
<p>For such programs we see that the GHC equivalent still runs 8.7 times faster. So it would be great if the reductions per seconds rate of <code>mhseval</code> could be improved.</p>
<h2 id="using-the-ffi-wrapper-to-compile-and-execute-haskell-programs">Using the FFI wrapper to compile and execute Haskell programs</h2>
<p>In this blog post, I have so far only used the parts of MiscroHs that deal either directly with the generation of Combinator code or with the execution of Combinator code.</p>
<p>But my two pull requests allow to embed MicroHs in GHC compiled Haskell programs in a much more complete way:</p>
<p>Let’s assume we have a file <code>Example.hs</code> with the following code:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Example</span> <span class="kw">where</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="ot">fac ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>fac <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>fac n <span class="ot">=</span> n <span class="op">*</span> fac(n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;computing some factorials&quot;</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> <span class="fu">map</span> fac [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>]</span></code></pre></div>
<p>Now let’s use MicroHs to compile and execute this code from some arbitrary GHC compiled Haskell program:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">MhsEval</span> (withMhsContext, eval, run)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">MicroHs.Main</span> <span class="kw">as</span> <span class="dt">MHS</span> (main)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">System.Process</span> (withArgs)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- use microHs to compile &#39;Example.hs&#39; to &#39;out.comb&#39;</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>  withArgs [<span class="st">&quot;Example.hs&quot;</span>] MHS.main</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- read the program &#39;out.comb&#39; into a string</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>  prg&#39; <span class="ot">&lt;-</span> <span class="fu">readFile</span> <span class="st">&quot;out.comb&quot;</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- use the MicroHs runtime to execute the program</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>  withMhsContext <span class="op">$</span> \ctx <span class="ot">-&gt;</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    run ctx prg&#39;</span></code></pre></div>
<p>The output of this program in GHCI looks like follows:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ex">ghci</span><span class="op">&gt;</span> main</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="ex">computing</span> some factorials</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="ex">[1,1,2,6,24,120,720,5040,40320,362880,3628800]</span></span></code></pre></div>
<p>Ok, this works as expected but it feels a bit clumsy to send the compiler output to a file and then read in that file to be able to execute it.
In order to improve this sketchy solution I integrated the MhsEval wrapper more tightly into the mhs compiler by implementing the <code>mhs -r</code> option also for GHC based compiles. With this goody the compile and execute cycle can be unified in a single command, as shown in the following snippet:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">MicroHs.Main</span> <span class="kw">as</span> <span class="dt">MHS</span> (main)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">System.Process</span> (withArgs)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- use MicroHs to compile AND execute the &#39;Example.hs&#39; program</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>  withArgs [<span class="st">&quot;-r&quot;</span>, <span class="st">&quot;Example.hs&quot;</span>] MHS.main</span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>In this post, I’ve demonstrated how to successfully integrate MicroHs as a backend for my toy combinator compiler, showcasing the elegance and power of combinatory logic as a compilation target. By adapting my compiler to emit MicroHs-compatible code, I was able to leverage the robust MicroHs graph-reduction runtime as an execution backend.</p>
<p>The performance benchmarks reveal that MicroHs consistently outperforms my toy runtime implementations, with speedups ranging from 10% (for tak) to 2.6x (for Ackermann).
There is still a huge gap to GHC compiled code.</p>
<p>The work also highlights the remarkable achievement of the MicroHs project itself: a complete, bootstrappable Haskell compiler that fits in a compact, hackable codebase while demonstrating sophisticated compilation techniques.
The presented FFI wrapper makes it possible to embed the complete MicroHs compiler and runtime within any GHC-compiled Haskell program. This opens up interesting possibilities for embedded haskell scripting and runtime code generation.</p>
<p>For anyone interested in compiler implementation, functional programming foundations, or combinatory logic, MicroHs provides an excellent playground for experimentation. The ability to embed it within larger Haskell applications makes it particularly valuable for research and teaching purposes.</p>
<h2 id="appendix-my-earlier-posts-on-combinatory-logic-and-graph-reduction">Appendix: my earlier posts on combinatory logic and graph-reduction</h2>
<ul>
<li><p>In <a href="https://thma.github.io/posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html">λ-Calculus, Combinatory Logic and Cartesian Closed Categories</a> I explained the basic concepts of compiling λ-Calculus based languages to combinatory logic expressions.
This post also explores the deep correspondence between simply‑typed λ‑calculus, combinatory logic, and cartesian closed categories (CCC).</p></li>
<li><p>In <a href="https://thma.github.io/posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html">Implementing a Functional Language with Graph Reduction</a> I’m describing a minimal functional language implemented in Haskell using three core components: (1) a parser for untyped λ‑calculus, (2) a compiler translating λ‑terms into a fixed combinator set (S,K,I,B,C,Y) via bracket abstraction with basic optimizations, and (3) a graph‑reduction engine using in‑place mutable STRef nodes to implement combinator rewrite rules efficiently</p></li>
<li><p><a href="https://thma.github.io/posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html">Evaluating SKI Combinators as Native Haskell Functions</a> This follow‑up provides an alternative to the graph reduction backend with direct evaluation of combinators as first‑class Haskell functions. The result is a significantly simpler and more compact implementation that achieves performance improvements by factors of 10 to 100 over the previous graph‑reduction approach</p></li>
<li><p><a href="https://thma.github.io/posts/2023-10-08-Optimizing-bracket-abstraction-for-combinator-reduction.html">Optimizing Bracket Abstraction for Combinator Reduction</a>
Building on the last two posts, this article focuses on improving the bracket‑abstraction phase.
I’m implementing several different optimizations of bracket abstraction introduced by Kiselyov. In particular I perform benchmarks to study their impact on execution speed.</p></li>
</ul>
]]></description>
    <pubDate>Fri, 15 Aug 2025 00:00:00 UT</pubDate>
    <guid>https://thma.github.io//posts/2025-08-15-Embedding-MicroHs.html</guid>
    <dc:creator>Thomas Mahler</dc:creator>
</item>
<item>
    <title>Real World REST APIs with Scotty and Generic-Persistence</title>
    <link>https://thma.github.io//posts/2024-12-05-real-worlds-rest-services-with-scotty-and-gp.html</link>
    <description><![CDATA[<div class="info">
    <em>Posted on December  5, 2024
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<p><a href="https://github.com/thma/scotty-gp-service"><img src="https://thma.github.io/img/forkme.png" height="20" ></a></p>
<h2 id="abstract">Abstract</h2>
<p>In this blog post I will show how to write a real world REST service in Haskell using the Scotty web framework and the generic-persistence database access library.</p>
<p>In particular I will demonstrate how to
- build CRUD operations against a database backend,
- add pagination support
- and secure access with token based authentication</p>
<p>My main motivation for this blog post is to show how compact and readable real world solutions can be written in Haskell.</p>
<h2 id="introduction">Introduction</h2>
<p>Some time ago, I discovered a compact and easy-to-understand article on <a href="https://camunda.com/resources/microservices/haskell/">how to create a REST service in Haskell with Scotty</a>.
The article provides a simple example of a REST service that allows to manage products in an in-memory data structure. The example shows how to use <a href="https://github.com/scotty-web/scotty">Scotty</a> to define the REST routes and how to use the <a href="https://github.com/haskell/aeson">aeson</a> library to serialize and deserialize JSON data.</p>
<p>The article was written by Camunda, a company that specializes in modeling and automating business processes.
They see orchestration of microservices as a key use case for their platform and the article provides examples in several programming languages (Java, C#, Python, Go, Typescript and Haskell).</p>
<p>When comparing the Haskell code with the other languages, I found the Haskell code to be the most concise and readable.
That came a bit of a surprise to me, as I had expected that languages like Go, Python or Typescript come with top notch libraries that allow to write REST services in a declarative and compact way.</p>
<p>As I found this langauge comparision based on a simple but practical example quite interesting, I created a <a href="https://github.com/thma/scotty-service">repository with the Haskell code</a> to invite people to experiment with the code.</p>
<p>I also contributed back to the authors by providing some improvements to the Haskell code made possible by the GHC2021 language features and some additional ones like <code>DeriveAnyClass</code>, <code>DeriveGeneric</code>, <code>DuplicateRecordFields</code> and <code>OverloadedRecordDot</code>. I also contributed some additional perspectives to the pro and cons section of the article. My suggestinions were well received and the article was updated accordingly.</p>
<p>The article ends with giving some ideas how the example code base could be extended to make it more useful in a real world scenario:</p>
<ul>
<li>Adding token based authentication</li>
<li>Adding a database backend</li>
<li>Adding pagination support to the <code>GET</code> requests</li>
</ul>
<p>In this blog post I will show how to implement these features using <code>scotty</code>, <code>wai</code> and <code>generic-persistence</code> libraries. I will not explain the basics setting up Scotty based REST services, as this is already well covered in the above mentioned article.</p>
<h2 id="adding-a-database-backend">Adding a database backend</h2>
<p>There are <a href="https://github.com/Zelenya/elephants">plenty of options to choose from</a> when it comes to Haskell database access libraries. I choose <a href="https://github.com/thma/generic-persistence#readme">generic-persistence</a> as it aims at minimizing boilerplate code and working in a declarative way. (Being the author of <code>generic-persistence</code> I might be biased here, but I think it is a good choice for this example).</p>
<h3 id="adding-generic-persistence-to-the-project">Adding generic-persistence to the project</h3>
<p>The first step is to add the library as a dependency to the <code>package.yaml</code> file:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dependencies</span><span class="kw">:</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">-</span><span class="at"> generic-persistence</span></span></code></pre></div>
<h3 id="mapping-the-data-model-to-the-data-base">Mapping the data model to the data base</h3>
<p>Next we have to enable the Datamodel to be used with <code>generic-persistence</code>. This is done by deriving the <code>Entity</code> type class for the <code>Product</code> datatype:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Database.GP</span>     (<span class="dt">Entity</span> (..))</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- Define a Product data type</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Product</span> <span class="ot">=</span> <span class="dt">Product</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> id          ::</span> <span class="dt">Int</span>,</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    name        ::</span> <span class="dt">Text</span>,</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    description ::</span> <span class="dt">Text</span>,</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    price       ::</span> <span class="dt">Double</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>, <span class="dt">ToJSON</span>, <span class="dt">FromJSON</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- Make Product an instance of Entity</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Entity</span> <span class="dt">Product</span> <span class="kw">where</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  idField <span class="ot">=</span> <span class="st">&quot;id&quot;</span>  </span></code></pre></div>
<p>In order to store a Haskell data type in a relational database, we need to define a mapping between the Haskell type and the corresponding database table. This mapping is defined by the <a href="https://hackage.haskell.org/package/generic-persistence-0.7.0.1/docs/Database-GP-Entity.html"><code>Entity</code></a> type class. This type class comes with default implementations for all methods which define the standard behaviour.
This default mapping will work for many cases, but it can be customized by overriding the default implementations.</p>
<p>By default <code>generic-persistence</code> would expect the primary key field to be named <code>productId</code>. If the primary key field has a different name as in our case, we have to declare it explicitely by defining <code>idField = "id"</code>.</p>
<p>Based on the <code>Entity</code> instance, <code>generic-persistence</code> can generate the necessary SQL queries to interact with the database. For example it will generate the following <code>CREATE TABLE</code> statement for the <code>Product</code> datatype:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- DDL for SQLlite</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> Product (<span class="kw">id</span> <span class="dt">INTEGER</span> <span class="kw">PRIMARY</span> <span class="kw">KEY</span>, name TEXT, description TEXT, price <span class="dt">REAL</span>);<span class="ot">&quot;</span></span></code></pre></div>
<p>If you are working with an existing database with deviating table names or column names, you can customize the mapping by providing a custom instance of <code>Entity</code> for the datatype.</p>
<h3 id="setting-up-the-database-connection">Setting up the database connection</h3>
<p>To interact with the database in a multi-threaded web server, we can’t use a single connection but need a connection pool. The <code>generic-persistence</code> library provides a function <code>createConnPool</code> to create a connection pool to a database.
In this example we use a SQLite database, but the library supports other databases as well. setting up a connection pool to a SQLite database is done as follows:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Create a connection pool to a SQLite db specified by its file path</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">sqlLitePool ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ConnectionPool</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>sqlLitePool dbFile <span class="ot">=</span> createConnPool <span class="dt">AutoCommit</span> dbFile connectSqlite3 <span class="dv">10</span> <span class="dv">100</span></span></code></pre></div>
<p>With this helper function defined we can now create a connection pool to the SQLite database and use it to interact with the database:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- create a connection pool to the SQLite database</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  pool <span class="ot">&lt;-</span> sqlLitePool <span class="st">&quot;sqlite.db&quot;</span></span></code></pre></div>
<h3 id="interacting-with-the-database">Interacting with the database</h3>
<p>Once we have create a connection pool to the database, we can use it in the Scotty actions to interact with the database.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- create a connection pool to the SQLite database</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  pool <span class="ot">&lt;-</span> sqlLitePool <span class="st">&quot;sqlite.db&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Start the web server</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  scotty <span class="dv">3000</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Define a route to get all products by performing a select query on the Product table.</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    get <span class="st">&quot;/products&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>      products <span class="ot">&lt;-</span> liftIO <span class="op">$</span> withResource pool <span class="op">$</span> \conn <span class="ot">-&gt;</span> </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        select <span class="op">@</span><span class="dt">Product</span> conn allEntries</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>      json products</span></code></pre></div>
<p>The <code>withResource</code> function is used to acquire a connection from the connection pool, perform the database operation and release the connection afterwards.
The <code>liftIO</code> is needed to lift the <code>IO</code> action into the Scotty action monad <code>ActionM</code>.</p>
<p>The signature of the <code>select</code> function is <code>select :: forall a. (Entity a) =&gt; Conn -&gt; WhereClauseExpr -&gt; IO [a]</code>.</p>
<p>In order to provide the type information for the <code>select</code> function, we use the type application syntax <code>@Product</code>.</p>
<p>The <code>allEntries</code> value is a predefined <code>WhereClauseExpr</code> that does not constrain the returned rows.</p>
<p>In order simplify the code further, we can define a helper function <code>withPooledConn</code> that hides the mechanics of acquiring the connection from the pool and the subsequent <code>liftIO</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- create a connection pool to the SQLite database</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  pool <span class="ot">&lt;-</span> sqlLitePool <span class="st">&quot;sqlite.db&quot;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- define Helper function to run a database action with a connection from the pool</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> withPooledConn <span class="ot">=</span> liftIO <span class="op">.</span> withResource pool </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Start the web server</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  scotty <span class="dv">3000</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Define a route to get all products by performing a select query on the Product table.</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    get <span class="st">&quot;/products&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>      products <span class="ot">&lt;-</span> withPooledConn <span class="op">$</span> \conn <span class="ot">-&gt;</span> </span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        select <span class="op">@</span><span class="dt">Product</span> conn allEntries</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>      json products</span></code></pre></div>
<p>Now we start writing the other CRUD operations for the <code>Product</code> datatype:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Define a route to get a product by ID</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    get <span class="st">&quot;/products/:id&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>      productIdParam <span class="ot">&lt;-</span> captureParam <span class="st">&quot;id&quot;</span><span class="ot"> ::</span> <span class="dt">ActionM</span> <span class="dt">Int</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>      prod <span class="ot">&lt;-</span> withPooledConn <span class="op">$</span> \conn <span class="ot">-&gt;</span> </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        selectById <span class="op">@</span><span class="dt">Product</span> conn productIdParam</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> prod <span class="kw">of</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> p  <span class="ot">-&gt;</span> json p</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> raiseStatus status404 <span class="st">&quot;not found&quot;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Define a route to create a new product</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    post <span class="st">&quot;/products&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>      newProduct <span class="ot">&lt;-</span> jsonData</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>      insertedProduct <span class="ot">&lt;-</span> withPooledConn <span class="op">$</span> \conn <span class="ot">-&gt;</span> </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        insert <span class="op">@</span><span class="dt">Product</span> conn newProduct</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>      json insertedProduct</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Define a route to update a product by ID</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    put <span class="st">&quot;/products/:id&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>      productIdParam <span class="ot">&lt;-</span> captureParam <span class="st">&quot;id&quot;</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>      updatedProduct <span class="ot">&lt;-</span> jsonData</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> updatedProductWithId <span class="ot">=</span> updatedProduct {<span class="fu">id</span> <span class="ot">=</span> productIdParam}<span class="ot"> ::</span> <span class="dt">Product</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>      updated <span class="ot">&lt;-</span> withPooledConn <span class="op">$</span> \conn <span class="ot">-&gt;</span> </span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        upsert <span class="op">@</span><span class="dt">Product</span> conn updatedProductWithId</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>      json updated</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Define a route to delete a product by ID</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    delete <span class="st">&quot;/products/:id&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>      productIdParam <span class="ot">&lt;-</span> captureParam <span class="st">&quot;id&quot;</span><span class="ot"> ::</span> <span class="dt">ActionM</span> <span class="dt">Int</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>      deleted <span class="ot">&lt;-</span> withPooledConn <span class="op">$</span> \conn <span class="ot">-&gt;</span> </span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>        deleteById <span class="op">@</span><span class="dt">Product</span> conn productIdParam</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>      json deleted</span></code></pre></div>
<p>The <code>selectById</code>, <code>insert</code>, <code>upsert</code> and <code>deleteById</code> functions work similar to the <code>select</code> function, so there is not much to explain here. Please note how the <code>generic-persistence</code> API allows to concentrate on the intented semantics of the operation and hides all the nitty-gritty technical details of data mapping and database operations.</p>
<h2 id="pagination-of-results">Pagination of results</h2>
<p>Pagination of large result sets is a common requirement for REST services.<br />
Many relational databases provide support for pagination through the <code>LIMIT</code> and <code>OFFSET</code> clauses in the <code>SELECT</code> statement.
<code>generic-persistence</code> provides a <code>limitOffset</code> operator that can be used to limit the number of rows returned and to specify the offset position of the first row to be returned. We will use this operator to implement pagination in the <code>GET /products</code> route.</p>
<p>When calling <code>GET /products</code> we want to be able to specify the page number and the number of records per page as the query parameters of the request.
So as an example the request <code>GET /products?page=4&amp;size=20</code> should return the 20 products starting from the 61st product in the database.
The response should also include a pagination info that contains:</p>
<ul>
<li>the current page number</li>
<li>the total number of pages</li>
<li>the total number of records</li>
<li>the number of the next page if it exists</li>
<li>the number of the previous page if it exists</li>
</ul>
<p>a concrete JSON structure could look like follows:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;currentPage&quot;</span><span class="fu">:</span> <span class="dv">4</span><span class="fu">,</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;nextPage&quot;</span><span class="fu">:</span> <span class="dv">5</span><span class="fu">,</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;prevPage&quot;</span><span class="fu">:</span> <span class="dv">3</span><span class="fu">,</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;totalPages&quot;</span><span class="fu">:</span> <span class="dv">5</span><span class="fu">,</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;totalRecords&quot;</span><span class="fu">:</span> <span class="dv">100</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<h3 id="a-pagination-data-type">A Pagination data type</h3>
<p>To represent the pagination info in Haskell, we define a data type <code>Pagination</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Define a Paging information data type</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Pagination</span> <span class="ot">=</span> <span class="dt">Pagination</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> totalRecords ::</span> <span class="dt">Int</span>,</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    currentPage  ::</span> <span class="dt">Int</span>,</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    totalPages   ::</span> <span class="dt">Int</span>,</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    nextPage     ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>,</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    prevPage     ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>, <span class="dt">ToJSON</span>, <span class="dt">FromJSON</span>)</span></code></pre></div>
<p>We also provide a helper function that allows to calculate the pagination info based on the total number of records, the current page and the requested page size:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Helper function to build pagination information</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">buildPagination ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Pagination</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>buildPagination totalRecords currentPage pageSize <span class="ot">=</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> totalPages <span class="ot">=</span> (totalRecords <span class="op">+</span> pageSize <span class="op">-</span> <span class="dv">1</span>) <span class="ot">`div`</span> pageSize</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>      nextPage</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> currentPage <span class="op">&lt;</span> <span class="dv">1</span>          <span class="ot">=</span> <span class="dt">Just</span> <span class="dv">1</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> currentPage <span class="op">&lt;</span> totalPages <span class="ot">=</span> <span class="dt">Just</span> (currentPage <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span>                <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>      prevPage</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> currentPage <span class="op">&gt;</span> totalPages <span class="ot">=</span> <span class="dt">Just</span> totalPages</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> currentPage <span class="op">&gt;</span> <span class="dv">1</span>          <span class="ot">=</span> <span class="dt">Just</span> (currentPage <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span>                <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="dt">Pagination</span> totalRecords currentPage totalPages nextPage prevPage</span></code></pre></div>
<h3 id="adding-pagination-to-the-get-products-route">Adding pagination to the <code>GET /products</code> route</h3>
<p>To add pagination to the <code>GET /products</code> route, we need to extract the <code>page</code> and <code>size</code> query parameters from the request and use them to fetch only the matching rows.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Define a route to list all products with pagination</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    get <span class="st">&quot;/products&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>      currentPage <span class="ot">&lt;-</span> queryParam <span class="st">&quot;page&quot;</span> <span class="ot">`catchAny`</span> (\_ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dv">1</span>)   <span class="co">-- default to 1</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>      pageSize    <span class="ot">&lt;-</span> queryParam <span class="st">&quot;size&quot;</span> <span class="ot">`catchAny`</span> (\_ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dv">20</span>)  <span class="co">-- default to 20</span></span></code></pre></div>
<p>Based on the <code>currentPage</code> and <code>pageSize</code> we can calculate the offset position of the rows to be returned:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> offset <span class="ot">=</span> (currentPage <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span><span class="ot"> pageSize ::</span> <span class="dt">Int</span></span></code></pre></div>
<p>Using <code>offset</code> and <code>pageSize</code> we can now perform the select query with the <code>limitOffset</code> operator provided by <code>generic-persistence</code> in order to select only the records of the requested page:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>      page <span class="ot">&lt;-</span> withPooledConn <span class="op">$</span> \conn <span class="ot">-&gt;</span> </span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>        select <span class="op">@</span><span class="dt">Product</span> conn (allEntries <span class="ot">`limitOffset`</span> (offset, pageSize))</span></code></pre></div>
<p>Finally we build the pagination info and include it in the output <code>ProductList</code> result. We’ll have to use the <code>count</code> function to get the total number of <code>Product</code> records in the database:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>      totalRecords <span class="ot">&lt;-</span> withPooledConn <span class="op">$</span> \conn <span class="ot">-&gt;</span> </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>        count <span class="op">@</span><span class="dt">Product</span> conn allEntries</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> info <span class="ot">=</span> buildPagination totalRecords currentPage pageSize</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>      json <span class="op">$</span> <span class="dt">ProductList</span> page info</span></code></pre></div>
<p>The <code>ProductList</code> data type is defined as follows:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ProductList</span> <span class="ot">=</span> <span class="dt">ProductList</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  { </span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    products   ::</span> [<span class="dt">Product</span>],</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    pagination ::</span> <span class="dt">Pagination</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>, <span class="dt">ToJSON</span>, <span class="dt">FromJSON</span>)</span></code></pre></div>
<p>A typical JSON output will look like follows (Assuming that we are calling <code>localhost:3000/products?page=4&amp;size=3</code>):</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;pagination&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;currentPage&quot;</span><span class="fu">:</span> <span class="dv">4</span><span class="fu">,</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;nextPage&quot;</span><span class="fu">:</span> <span class="dv">5</span><span class="fu">,</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;prevPage&quot;</span><span class="fu">:</span> <span class="dv">3</span><span class="fu">,</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;totalPages&quot;</span><span class="fu">:</span> <span class="dv">34</span><span class="fu">,</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;totalRecords&quot;</span><span class="fu">:</span> <span class="dv">100</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">},</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;products&quot;</span><span class="fu">:</span> <span class="ot">[</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;description&quot;</span><span class="fu">:</span> <span class="st">&quot;Description 10&quot;</span><span class="fu">,</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="dv">10</span><span class="fu">,</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;Product 10&quot;</span><span class="fu">,</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;price&quot;</span><span class="fu">:</span> <span class="fl">119.99</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">}</span><span class="ot">,</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;description&quot;</span><span class="fu">:</span> <span class="st">&quot;Description 11&quot;</span><span class="fu">,</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="dv">11</span><span class="fu">,</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;Product 11&quot;</span><span class="fu">,</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;price&quot;</span><span class="fu">:</span> <span class="fl">129.99</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    <span class="fu">}</span><span class="ot">,</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;description&quot;</span><span class="fu">:</span> <span class="st">&quot;Description 12&quot;</span><span class="fu">,</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="dv">12</span><span class="fu">,</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;Product 12&quot;</span><span class="fu">,</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;price&quot;</span><span class="fu">:</span> <span class="fl">139.99</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    <span class="fu">}</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>  <span class="ot">]</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<h2 id="adding-token-based-authentication">Adding token based authentication</h2>
<p><code>Scotty</code> is build on top of the <code>wai</code> web application interface, which allows to add middlewares to the application. Middlewares are functions that can modify the request and response of the application.
To add token based authentication to the service, we can use the <code>wai-middleware-bearer</code> middleware. This middleware allows to extract the token from the <code>Authorization</code> header and to validate it against a list of known tokens.</p>
<p>Using such a middleware is a good practice as it allows to separate the business logic of the service (as defined by the Scotty routes) from other concerns like.</p>
<ul>
<li>logging</li>
<li>request validation</li>
<li>authentication / authorization</li>
<li>compression</li>
<li>HTTPS enforcement.</li>
</ul>
<p>Another good thing about wai middlewares is that they can be composed in a pipeline, so that each middleware can focus on a single concern. And they work independently of the actual web application framework used (like Scotty, Servant and Yesod).</p>
<h3 id="adding-middlewares-to-a-scotty-application">Adding middlewares to a Scotty application</h3>
<p>Adding a middleware to a <code>Scotty</code> application is done by using the <code>middleware</code> function provided by the library.
For example we could add a middleware that logs all incoming requests to the console:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Start the web server</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  scotty <span class="dv">3000</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Add middleware to log all incoming requests</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    middleware logStdoutDev</span></code></pre></div>
<p>This will produce a log output like follows:</p>
<pre class="shell"><code>GET /products
  Params: [(&quot;page&quot;,&quot;2&quot;),(&quot;size&quot;,&quot;13&quot;)]
  Accept: */*
  Status: 200 OK 0.004865s
POST /products/
  Request Body: {
    &quot;description&quot;: &quot;classic pink blue&quot;,
    &quot;id&quot;: 3,
    &quot;name&quot;: &quot;Lava Lamp&quot;,
    &quot;price&quot;: 499.99
  }
  Accept: */*
  Status: 200 OK 0.00759s</code></pre>
<h3 id="adding-the-wai-middleware-bearer-middleware">Adding the <code>wai-middleware-bearer</code> middleware</h3>
<p>To add the <code>wai-middleware-bearer</code> middleware we first have to add it as a dependency to the <code>package.yaml</code> file:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dependencies</span><span class="kw">:</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">...</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">- wai-middleware-bearer</span></span></code></pre></div>
<p>The package <code>Network.Wai.Middleware.BearerTokenAuth</code> provides sevaral functions that can be used to create a middleware that validates the token in the <code>Authorization</code> header. For example there is a function <code>tokenListAuth :: [ByteString] -&gt; Middleware</code> that takes a list of known tokens and returns a middleware that validates the token against this list:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>  scotty <span class="dv">3000</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- validate token against a list of known tokens</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    middleware <span class="op">$</span> tokenListAuth [<span class="st">&quot;secret&quot;</span>, <span class="st">&quot;top-secret&quot;</span>]</span></code></pre></div>
<p>In a real world scenario the tokens would be stored in a secure way. But even then it could still a bit too static as the tokens would be only loaded once when the application starts.</p>
<h3 id="using-a-custom-token-validator-function">Using a custom token validator function</h3>
<p>We are looking for a more dynamic way to validate the tokens, that will allow to change the tokens without restarting the application.</p>
<p><code>wai-middleware-bearer</code> supports using custom token validators that can be passed to the middleware by using the <code>tokenAuth :: TokenValidator -&gt; Middleware</code> function.
Here <code>TokenValidator</code> is a type synonym for a validation function: <code>type TokenValidator = ByteString -&gt; IO Bool</code>. So we will use <code>tokenAuth</code> to pass in our custom token validator function to create a middleware.</p>
<p>For this we will provide our own token validator function <code>validateToken :: ConnectionPool -&gt; TokenValidator</code> that will be called for each request to validate the token against the database.
In this way we can change the tokens in the database without restarting the application.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">validateToken ::</span> <span class="dt">ConnectionPool</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>validateToken pool token <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  now <span class="ot">&lt;-</span> getCurrentTime                     <span class="co">-- get the current time</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  tokens <span class="ot">&lt;-</span> withResource pool <span class="op">$</span> \conn <span class="ot">-&gt;</span>    <span class="co">-- use a connection from the pool</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    select <span class="op">@</span><span class="dt">BearerToken</span> conn                <span class="co">-- to select tokens from the BearerToken table    </span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>      (field <span class="st">&quot;token&quot;</span> <span class="op">=.</span> token <span class="op">&amp;&amp;.</span>           <span class="co">-- where the token matches, and </span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>       field <span class="st">&quot;expiry&quot;</span> <span class="op">&gt;.</span> now)               <span class="co">-- expiry is in the future</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">not</span> (<span class="fu">null</span> tokens)                <span class="co">-- return True if a valid token exists</span></span></code></pre></div>
<h2 id="summary">Summary</h2>
<p>In this blog post we have shown how to extend the simple Scotty based REST service example from the Camunda article with a database backend, pagination support and token based authentication.</p>
<p>We have shown that Haskell is a great language for writing real world REST services. The code is concise, readable and easy to maintain. The type system helps to catch many errors at compile time and the GHC language extensions allow to write even more concise code.</p>
<p>As a developer, you simply state your intentions in a declaratice way and delegate all the technical details to the libraries.</p>
<p>I hope you enjoyed this blog post and found it useful. If you have any questions or suggestions, please feel free to contact me.</p>
]]></description>
    <pubDate>Thu, 05 Dec 2024 00:00:00 UT</pubDate>
    <guid>https://thma.github.io//posts/2024-12-05-real-worlds-rest-services-with-scotty-and-gp.html</guid>
    <dc:creator>Thomas Mahler</dc:creator>
</item>
<item>
    <title>Optimizing bracket abstraction for Combinator Reduction</title>
    <link>https://thma.github.io//posts/2023-10-08-Optimizing-bracket-abstraction-for-combinator-reduction.html</link>
    <description><![CDATA[<div class="info">
    <em>Posted on October  8, 2023
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<p><a href="https://github.com/thma/lambda-ski/actions"><img src="https://github.com/thma/lambda-ski/workflows/Haskell-CI/badge.svg" alt="Actions Status" /></a>
<a href="https://github.com/thma/lambda-ski"><img src="https://thma.github.io/img/forkme.png" height="20" ></a></p>
<h2 id="abstract">Abstract</h2>
<p>In this post I will show how to significantly improve the performance of combinator based reducers by using a alternative abstraction algorithms. These algorithms are based on the paper <a href="https://okmij.org/ftp/tagless-final/ski.pdf">λ to SKI, Semantically</a> by Oleg Kiselyov and closely follow <a href="https://crypto.stanford.edu/~blynn/lambda/kiselyov.html">Ben Lynn’s implementation of Kiselyov’s ideas</a>.</p>
<p>I will also give detailed comparisons of the different approaches regarding the size of the emitted code and execution performance on different reducers.</p>
<h2 id="introduction">Introduction</h2>
<p>In previous blog posts I have shown how functional languages can be implemented using a small set of combinators.</p>
<p><strong>The first post</strong>, <a href="https://thma.github.io/posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html">Implementing a functional language with Graph Reduction</a> described an approach that sets up three major components:</p>
<ul>
<li><p>A parser for a tiny functional language based on the untyped λ-calculus.</p></li>
<li><p>A compiler from λ-calculus to a fixed set of combinatory logic combinators (S,K,I,B,C and Y (aka. SICKBY)). This compiler uses traditional bracket abstraction algorithms to encode λ-terms as combinators.</p></li>
<li><p>A graph-reduction engine which implements the combinator rewrite rules as an efficient graph reduction</p></li>
</ul>
<p><strong>In the second post</strong>, <a href="https://thma.github.io/posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html">Evaluating SKI combinators as native Haskell functions</a>, I showed how the combinators can be implemented as native Haskell functions. This allows to evaluate the combinators directly in Haskell without the need for a graph reduction engine.</p>
<p>The parser and the compiler of the first post could be reused without any changes. I just had to plug in a different execution engine. This time based on native Haskell functions instead of graph reduction.</p>
<p>I also did some performance measurements and found that the version using native Haskell functions is about 10-100 times faster than the graph reduction engine.</p>
<p>Another significant finding was that the performance of functions with two or more arguments was significantly worse than the performance of functions with one argument.</p>
<p>This is caused by the inefficient code generation of the classic bracket abstraction: <a href="https://tromp.github.io/cl/LC.pdf">The output size grows quadratic</a> with internal complexity and number of variables. As each additional combinator or application will require additional execution time it’s easy to see why a quadratic growth in combinator code size will drastically decrease performance. There have been many attempts to optimize bracket abstraction by <a href="https://www.cantab.net/users/antoni.diller/brackets/intro.html">introducing additional combinators</a> and by applying additional optimization rules.</p>
<p><strong>In the present post</strong> I will show how to significantly improve the performnce by using an alternative abstraction algorithm. This algorithm is based on the paper <a href="https://okmij.org/ftp/tagless-final/ski.pdf">Optimizing bracket abstraction</a> by Oleg Kiselyov.</p>
<p>My implementation closely follows Ben Lynn’s implementation of Kiselyov’s algorithm in <a href="https://crypto.stanford.edu/~blynn/lambda/kiselyov.html">his blog post</a>. I have made only minor changes to make the code more readable and to make it work with the parser and compiler of the first post.</p>
<h2 id="from-λ-calculus-to-combinators">From λ-calculus to combinators</h2>
<p>My parser can parse programs of a very rudimentary language that is basically just pure λ-calculus plus integers. Here is an example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sqr  <span class="ot">=</span> λx<span class="op">.</span> <span class="op">*</span> x x</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> sqr <span class="dv">3</span></span></code></pre></div>
<p>The parser will produce an environment of top-level definitions from this program:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>[(<span class="st">&quot;sqr&quot;</span>,<span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;*&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))), </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a> (<span class="st">&quot;main&quot;</span>,<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;sqr&quot;</span>) (<span class="dt">Int</span> <span class="dv">3</span>))]</span></code></pre></div>
<p>Data types for λ-expressions and the environment are defined as follows:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Var</span> <span class="dt">String</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Int</span> <span class="dt">Integer</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">String</span> <span class="dt">Expr</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Environment</span> <span class="ot">=</span> [(<span class="dt">String</span>, <span class="dt">Expr</span>)]</span></code></pre></div>
<p>Now we can define a compiler that translates such λ-expressions to combinator terms.
(You will find the complete code in <a href="https://github.com/thma/lambda-ski/blob/main/src/Kiselyov.hs">Kiselyov.hs</a></p>
<p>Our journey begins by translating λ-expressions to a data type <code>DB</code> which is quite similar to the λ-calculus terms but uses indices instead of variable names. This is done by the function <code>deBruijn</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Peano</span> <span class="ot">=</span> <span class="dt">Succ</span> <span class="dt">Peano</span> <span class="op">|</span> <span class="dt">Zero</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DB</span> <span class="ot">=</span> <span class="dt">N</span> <span class="dt">Peano</span> <span class="op">|</span> <span class="dt">L</span> <span class="dt">DB</span> <span class="op">|</span> <span class="dt">A</span> <span class="dt">DB</span> <span class="dt">DB</span> <span class="op">|</span> <span class="dt">Free</span> <span class="dt">String</span> <span class="op">|</span> <span class="dt">IN</span> <span class="dt">Integer</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">deBruijn ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">DB</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>deBruijn <span class="ot">=</span> go [] <span class="kw">where</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  go binds <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Var</span> x <span class="ot">-&gt;</span> <span class="fu">maybe</span> (<span class="dt">Free</span> x) <span class="dt">N</span> <span class="op">$</span> <span class="fu">index</span> x binds</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Lam</span> x t <span class="ot">-&gt;</span> <span class="dt">L</span> <span class="op">$</span> go (x<span class="op">:</span>binds) t</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">App</span> t u <span class="ot">-&gt;</span> <span class="dt">A</span> (go binds t) (go binds u)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Int</span> i <span class="ot">-&gt;</span> <span class="dt">IN</span> i  </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="fu">index</span><span class="ot"> ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Peano</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="fu">index</span> x xs <span class="ot">=</span> <span class="fu">lookup</span> x <span class="op">$</span> <span class="fu">zip</span> xs <span class="op">$</span> <span class="fu">iterate</span> <span class="dt">Succ</span> <span class="dt">Zero</span>    </span></code></pre></div>
<p>Lets see how this works on a simple <code>main</code> functions:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> source <span class="ot">=</span> <span class="st">&quot;main = λx y. * x y&quot;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> env <span class="ot">=</span> parseEnvironment source</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;The parsed environment of named lambda expressions:&quot;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM_</span> <span class="fu">print</span> env</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;&quot;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;The main expression in de Bruijn notation:&quot;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM_</span> (<span class="fu">print</span> <span class="op">.</span> Data.Bifunctor.second deBruijn) env</span></code></pre></div>
<p>This will produce the following output:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">The</span> parsed environment <span class="kw">of</span> named lambda expressions<span class="op">:</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;main&quot;</span>,<span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;y&quot;</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;*&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)) (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>))))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="dt">The</span> main expression <span class="kw">in</span> de <span class="dt">Bruijn</span> notation<span class="op">:</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;main&quot;</span>,<span class="dt">L</span> (<span class="dt">L</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;*&quot;</span>) (<span class="dt">N</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>))) (<span class="dt">N</span> <span class="dt">Zero</span>))))</span></code></pre></div>
<p>It’s easy to see that the de Bruijn notation is just a different representation of the λ-term. The only difference is that the variable names are replaced by indices.
The innermost lambda-abstraction binds the variable <code>y</code> which is represented by the index <code>Zero</code>. The next lambda-abstraction binds the variable <code>x</code> which is represented by the index <code>Succ Zero</code>.
This notation is quite helpful as it allows to systematically adress variables by their respective position in a complex term.</p>
<p>But why are we using Peano numbers for the indices? Why not just use integers?
Well it’s definitely possible to <a href="https://crypto.stanford.edu/~blynn/lambda/cl.html">use integers as indices</a>.
But there is a good reason to use Peano numbers in our case:
In the subsequent compilation steps we want to be able to do pattern matching on the indices. This is possible with Peano numbers, because they are defined as an algebraic data type:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Peano</span> <span class="ot">=</span> <span class="dt">Succ</span> <span class="dt">Peano</span> <span class="op">|</span> <span class="dt">Zero</span></span></code></pre></div>
<p>Starting with the de Bruijn notation Ben Lynn’s implementation of Kiselyov’s algorithm builds up a series of six increasingly optimized compilers that translate λ-expressions to combinator terms:</p>
<ul>
<li>a plain compiler without any optimizations (<code>compilePlain</code>)</li>
<li>a compiler that implements K-optimization (<code>compileK</code>)</li>
<li>a compiler that implements K- and Eta-optimization (<code>compileEta</code>)</li>
<li>a compiler that generates code with <em>Bulk Combinators</em> (<code>compileBulk</code>)</li>
<li>a compiler that eliminates <em>Bulk Combinators</em> with linear size(<code>compileBulkLinear</code>)</li>
<li>a compiler that eliminates <em>Bulk Combinators</em> with logarithmic size(<code>compileBulkLog</code>)</li>
</ul>
<p>I’ll don’t want to go into all the details of the algorithms. <a href="https://crypto.stanford.edu/~blynn/lambda/kiselyov.html">Ben’s blog post</a> is a great resource for this. I’ll just give a brief overview of the compilation outputs of the different compilers. And then I’ll focus on performance comparisons between the different approaches.
I will use <a href="https://github.com/thma/lambda-ski/blob/main/src/LambdaToSKI.hs">my original compiler</a> <code>compileBracket</code> based on the classic (recursively optimized) bracket abstraction as a baseline for the performance comparisons.</p>
<h3 id="the-simple-main-example">The simple <code>main</code> example</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> λx y<span class="op">.</span> <span class="op">*</span> x y</span></code></pre></div>
<table>
<thead>
<tr>
<th>Compiler</th>
<th>Output</th>
<th>Code Size</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>compileBracket</code></td>
<td><code>MUL</code></td>
<td>1</td>
</tr>
<tr>
<td><code>compilePlain</code></td>
<td><code>R I(B S(B(B MUL)(B K I)))</code></td>
<td>10</td>
</tr>
<tr>
<td><code>compileK</code></td>
<td><code>R I(B B(B MUL I)))</code></td>
<td>7</td>
</tr>
<tr>
<td><code>compileEta</code></td>
<td><code>MUL</code></td>
<td>1</td>
</tr>
<tr>
<td><code>compileBulk</code></td>
<td><code>MUL</code></td>
<td>1</td>
</tr>
<tr>
<td><code>compileBulkLinear</code></td>
<td><code>MUL</code></td>
<td>1</td>
</tr>
<tr>
<td><code>compileBulkLog</code></td>
<td><code>MUL</code></td>
<td>1</td>
</tr>
</tbody>
</table>
<p>From this simple example it’s obvious that <code>compilePlain</code> and <code>compileK</code> generate a lot of redundant code. All the other compilers generate the same output as the baseline.</p>
<p>In order to have a simple metric for quality of the code generation I am showing the code size of the generated code for each compiler. The code size is measured in the number of emitted combinators. The <code>codeSize</code> function is defined as follows:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">codeSize ::</span> <span class="dt">CL</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>codeSize (<span class="dt">Com</span> _) <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>codeSize (<span class="dt">INT</span> _) <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>codeSize (t <span class="op">:@</span> u) <span class="ot">=</span> codeSize t <span class="op">+</span> codeSize u</span></code></pre></div>
<p>Please also note that the Kiselyov algorithms may emit code for an additional <code>R</code> combinator with the following reduction rule:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">R</span> f g x <span class="ot">=</span> g x f  </span></code></pre></div>
<h3 id="the-factorial-function">The factorial function</h3>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>fact <span class="ot">=</span> y(λf n<span class="op">.</span> <span class="kw">if</span> (is0 n) <span class="dv">1</span> (<span class="op">*</span> n (f (sub1 n))))</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> fact <span class="dv">100</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- in de Bruijn Notation</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;fact&quot;</span>, <span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;y&quot;</span>) (<span class="dt">L</span> (<span class="dt">L</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;if&quot;</span>) (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;is0&quot;</span>) (<span class="dt">N</span> <span class="dt">Zero</span>))) (<span class="dt">IN</span> <span class="dv">1</span>)) (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;*&quot;</span>) (<span class="dt">N</span> <span class="dt">Zero</span>)) (<span class="dt">A</span> (<span class="dt">N</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>)) (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;sub1&quot;</span>) (<span class="dt">N</span> <span class="dt">Zero</span>))))))))</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;main&quot;</span>, <span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;fact&quot;</span>) (<span class="dt">IN</span> <span class="dv">100</span>))</span></code></pre></div>
<table style="width:100%;">
<colgroup>
<col style="width: 7%" />
<col style="width: 85%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr>
<th>Compiler</th>
<th>Output</th>
<th>Code Size</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>compileBracket</code></td>
<td><code>Y(B' S(C' IF ZEROP 1)(B' S MUL(C' S K SUB1))) 100</code></td>
<td>13</td>
</tr>
<tr>
<td><code>compilePlain</code></td>
<td><code>Y(B(S(R 1(B IF(B ZEROP I))))(B(S(B MUL I))(R(B SUB1 I)(B S(B K I))))) 100</code></td>
<td>23</td>
</tr>
<tr>
<td><code>compileK</code></td>
<td><code>Y(B(S(C(B IF(B ZEROP I)) 1))(B(S(B MUL I))(R(B SUB1 I)(B B I)))) 100</code></td>
<td>21</td>
</tr>
<tr>
<td><code>compileEta</code></td>
<td><code>Y(B(S(C(B IF ZEROP) 1))(B(S MUL)(R SUB1 B))) 100</code></td>
<td>13</td>
</tr>
<tr>
<td><code>compileBulk</code></td>
<td><code>Y(B(S(C(B IF ZEROP) 1))(B(S MUL)(C C SUB1 B))) 100</code></td>
<td>14</td>
</tr>
<tr>
<td><code>compileBulkLinear</code></td>
<td><code>Y(B(S(C(B IF ZEROP) 1))(B(S MUL)(C C SUB1 B))) 100</code></td>
<td>14</td>
</tr>
<tr>
<td><code>compileBulkLog</code></td>
<td><code>Y(B(S(C(B IF ZEROP) 1))(B(S MUL)(C C SUB1 B))) 100</code></td>
<td>14</td>
</tr>
</tbody>
</table>
<p>What’s interesting here is that only <code>compileEta</code> produces code of the same size as the baseline. All others produce code that uses at least one more combinator. Again <code>compilePlain</code> and <code>compileK</code> generate the largest code sizes.</p>
<h3 id="the-fibonacci-function">The fibonacci function</h3>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>fib  <span class="ot">=</span> y(λf n<span class="op">.</span> <span class="kw">if</span> (is0 n) <span class="dv">1</span> (<span class="kw">if</span> (eql n <span class="dv">1</span>) <span class="dv">1</span> (<span class="op">+</span> (f (sub1 n)) (f (sub n <span class="dv">2</span>)))))</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> fib <span class="dv">10</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- in de Bruijn notation</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;fib&quot;</span>, <span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;y&quot;</span>) (<span class="dt">L</span> (<span class="dt">L</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;if&quot;</span>) (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;is0&quot;</span>) (<span class="dt">N</span> <span class="dt">Zero</span>))) (<span class="dt">IN</span> <span class="dv">1</span>)) (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;if&quot;</span>) (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;eql&quot;</span>) (<span class="dt">N</span> <span class="dt">Zero</span>)) (<span class="dt">IN</span> <span class="dv">1</span>))) (<span class="dt">IN</span> <span class="dv">1</span>)) (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;+&quot;</span>) (<span class="dt">A</span> (<span class="dt">N</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>)) (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;sub1&quot;</span>) (<span class="dt">N</span> <span class="dt">Zero</span>)))) (<span class="dt">A</span> (<span class="dt">N</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>)) (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;sub&quot;</span>) (<span class="dt">N</span> <span class="dt">Zero</span>)) (<span class="dt">IN</span> <span class="dv">2</span>)))))))))</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;main&quot;</span>, <span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;fib&quot;</span>) (<span class="dt">IN</span> <span class="dv">10</span>))</span></code></pre></div>
<table style="width:100%;">
<colgroup>
<col style="width: 7%" />
<col style="width: 85%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr>
<th>Compiler</th>
<th>Output</th>
<th>Code Size</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>compileBracket</code></td>
<td><code>Y(B' S(C' IF ZEROP 1)(B' S(C' IF(C EQL 1) 1)(S' S(B' S(K ADD)(C' S K SUB1))(C' S K(C SUB 2))))) 10</code></td>
<td>27</td>
</tr>
<tr>
<td><code>compilePlain</code></td>
<td><code>Y(B(S(R 1(B IF(B ZEROP I))))(B(S(R 1(B IF(R 1(B EQL I)))))(S(B S(B(B ADD)(R(B SUB1 I)(B S(B K I)))))(R(R 2(B SUB I))(B S(B K I)))))) 10</code></td>
<td>43</td>
</tr>
<tr>
<td><code>compileK</code></td>
<td><code>Y(B(S(C(B IF(B ZEROP I)) 1))(B(S(C(B IF(C(B EQL I) 1)) 1))(S(B S(B(B ADD)(R(B SUB1 I)(B B I))))(R(C(B SUB I) 2)(B B I))))) 10</code></td>
<td>39</td>
</tr>
<tr>
<td><code>compileEta</code></td>
<td><code>Y(B(S(C(B IF ZEROP) 1))(B(S(C(B IF(C EQL 1)) 1))(S(B S(B(B ADD)(R SUB1 B)))(R(C SUB 2) B)))) 10</code></td>
<td>27</td>
</tr>
<tr>
<td><code>compileBulk</code></td>
<td><code>Y(B(S(C(B IF ZEROP) 1))(B(S(C(B IF(C EQL 1)) 1))(S2(B2 ADD(C C SUB1 B))(C C(C SUB 2) B)))) 10</code></td>
<td>26</td>
</tr>
<tr>
<td><code>compileBulkLinear</code></td>
<td><code>Y(B(S(C(B IF ZEROP) 1))(B(S(C(B IF(C EQL 1)) 1))(B(B S) B S(B B B ADD(C C SUB1 B))(C C(C SUB 2) B)))) 10</code></td>
<td>32</td>
</tr>
<tr>
<td><code>compileBulkLog</code></td>
<td><code>Y(B(S(C(B IF ZEROP) 1))(B(S(C(B IF(C EQL 1)) 1))(S B I(B(B S) B) I(S B I B ADD(C C SUB1 B))(C C(C SUB 2) B)))) 10</code></td>
<td>36</td>
</tr>
</tbody>
</table>
<p>Here we see that <code>compileEta</code> produce code of the same size as the baseline. <code>compileBulk</code> generates code with one less combinator.</p>
<p>Please also note that <code>compileBulk</code> now emits code for additional bulk combinators <code>S2</code> and <code>B2</code>. I’ll come back to the semantics of these later.</p>
<h3 id="the-ackermann-function">The ackermann function</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>ack  <span class="ot">=</span> y(λf n m<span class="op">.</span> <span class="kw">if</span> (is0 n) (<span class="op">+</span> m <span class="dv">1</span>) (<span class="kw">if</span> (is0 m) (f (sub1 n) <span class="dv">1</span>) (f (sub1 n) (f n (sub1 m)))))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> ack <span class="dv">2</span> <span class="dv">2</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- in de Bruijn notation</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;ack&quot;</span>, <span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;y&quot;</span>) (<span class="dt">L</span> (<span class="dt">L</span> (<span class="dt">L</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;if&quot;</span>) (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;is0&quot;</span>) (<span class="dt">N</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>)))) (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;+&quot;</span>) (<span class="dt">N</span> <span class="dt">Zero</span>)) (<span class="dt">IN</span> <span class="dv">1</span>))) (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;if&quot;</span>) (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;is0&quot;</span>) (<span class="dt">N</span> <span class="dt">Zero</span>))) (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">N</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>))) (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;sub1&quot;</span>) (<span class="dt">N</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>)))) (<span class="dt">IN</span> <span class="dv">1</span>))) (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">N</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>))) (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;sub1&quot;</span>) (<span class="dt">N</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>)))) (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">N</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>))) (<span class="dt">N</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>))) (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;sub1&quot;</span>) (<span class="dt">N</span> <span class="dt">Zero</span>))))))))))</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;main&quot;</span>, <span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;ack&quot;</span>) (<span class="dt">IN</span> <span class="dv">2</span>)) (<span class="dt">IN</span> <span class="dv">2</span>))</span></code></pre></div>
<table style="width:100%;">
<colgroup>
<col style="width: 7%" />
<col style="width: 85%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr>
<th>Compiler</th>
<th>Output</th>
<th>Code Size</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>compileBracket</code></td>
<td><code>Y(B' S(B S(C'(B S K)(B IF ZEROP)(C ADD 1)))(S'(B S(S(K S)))(B' S(K(S(B IF ZEROP)))(B' S(K K)(C' S(C' S K SUB1)(K 1))))(S'(B S(S(K(B S K))))(C' S K SUB1)(C' S(S(K(B S K)))(K SUB1))))) 2 2</code></td>
<td>59</td>
</tr>
<tr>
<td><code>compilePlain</code></td>
<td><code>Y(B(S(B S(R(R 1(B ADD I))(B S(B(B IF)(B(B ZEROP)(B K I)))))))(S(B S(B(B S)(B(B(S(B IF(B ZEROP I))))(B(B(R 1))(R(B(B SUB1)(B K I))(B S(B(B S)(B(B K)(B K I)))))))))(S(B S(B(B S)(R(B(B SUB1)(B K I))(B S(B(B S)(B(B K)(B K I)))))))(B(R(B SUB1 I))(B(B S)(R(B K I)(B S(B(B S)(B(B K)(B K I)))))))))) 2 2</code></td>
<td>103</td>
</tr>
<tr>
<td><code>compileK</code></td>
<td><code>Y(B(S(B S(R(C(B ADD I) 1)(B B(B IF(B ZEROP I))))))(S(B S(B(B S)(B(B(C(B IF(B ZEROP I))))(B(R 1)(R(B SUB1 I)(B B I))))))(S(B S(B(B B)(R(B SUB1 I)(B B I))))(B(R(B SUB1 I))(B(B B)(R I(B B I))))))) 2 2</code></td>
<td>66</td>
</tr>
<tr>
<td><code>compileEta</code></td>
<td><code>Y(B(S(B S(R(C ADD 1)(B B(B IF ZEROP)))))(S(B S(B(B S)(B(B(C(B IF ZEROP)))(B(R 1)(R SUB1 B)))))(S(B S(B(B B)(R SUB1 B)))(B(R SUB1)(B B))))) 2 2</code></td>
<td>44</td>
</tr>
<tr>
<td><code>compileBulk</code></td>
<td><code>Y(B(S2(C C(C ADD 1)(B B(B IF ZEROP))))(S3(B2(C(B IF ZEROP))(C C2 1(C C SUB1 B)))(S2(B2 B(C C SUB1 B))(C C2 SUB1(B B))))) 2 2</code></td>
<td>36</td>
</tr>
<tr>
<td><code>compileBulkLinear</code></td>
<td><code>Y(B(B(B S) B S(C C(C ADD 1)(B B(B IF ZEROP))))(B(B S) B(B(B S) B S)(B B B(C(B IF ZEROP))(C(B(B C) B C) 1(C C SUB1 B)))(B(B S) B S(B B B B(C C SUB1 B))(C(B(B C) B C) SUB1(B B))))) 2 2</code></td>
<td>64</td>
</tr>
<tr>
<td><code>compileBulkLog</code></td>
<td><code>Y(B(S B I(B(B S) B) I(C C(C ADD 1)(B B(B IF ZEROP))))(B(B(B(B S) B))(S B I)(B(B S) B) I(S B I B(C(B IF ZEROP))(C(S B I(B(B C) B) I) 1(C C SUB1 B)))(S B I(B(B S) B) I(S B I B B(C C SUB1 B))(C(S B I(B(B C) B) I) SUB1(B B))))) 2 2</code></td>
<td>83</td>
</tr>
</tbody>
</table>
<p>As mentioned in my last post the output size of braxcket abstraction grows quadratic with the number of variables.
In this case with three variables the output size for the bracket abstraction is already significantly larger than for
the previous example with two variables.</p>
<p>Now the Kiselyov algorithms really start to shine. <code>compileEta</code> produces code is significantly smaller as the baseline. And <code>compileBulk</code> output is even smaller.</p>
<h3 id="the-tak-function">The tak function</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>tak  <span class="ot">=</span> y(λf x y z<span class="op">.</span> (<span class="kw">if</span> (geq y x) z (f (f (sub1 x) y z) (f (sub1 y) z x) (f (sub1 z) x y ))))</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> tak <span class="dv">7</span> <span class="dv">4</span> <span class="dv">2</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- in de Bruijn notation</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;tak&quot;</span>,<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;y&quot;</span>) (<span class="dt">L</span> (<span class="dt">L</span> (<span class="dt">L</span> (<span class="dt">L</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;if&quot;</span>) (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;geq&quot;</span>) (<span class="dt">N</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>))) (<span class="dt">N</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>))))) (<span class="dt">N</span> <span class="dt">Zero</span>)) (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">N</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>)))) (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">N</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>)))) (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;sub1&quot;</span>) (<span class="dt">N</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>))))) (<span class="dt">N</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>))) (<span class="dt">N</span> <span class="dt">Zero</span>))) (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">N</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>)))) (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;sub1&quot;</span>) (<span class="dt">N</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>)))) (<span class="dt">N</span> <span class="dt">Zero</span>)) (<span class="dt">N</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>))))) (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">N</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>)))) (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;sub1&quot;</span>) (<span class="dt">N</span> <span class="dt">Zero</span>))) (<span class="dt">N</span> (<span class="dt">Succ</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>)))) (<span class="dt">N</span> (<span class="dt">Succ</span> <span class="dt">Zero</span>))))))))))</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>(<span class="st">&quot;main&quot;</span>,<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">A</span> (<span class="dt">Free</span> <span class="st">&quot;tak&quot;</span>) (<span class="dt">IN</span> <span class="dv">7</span>)) (<span class="dt">IN</span> <span class="dv">4</span>)) (<span class="dt">IN</span> <span class="dv">2</span>))</span></code></pre></div>
<table style="width:100%;">
<colgroup>
<col style="width: 7%" />
<col style="width: 85%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr>
<th>Compiler</th>
<th>Output</th>
<th>Code Size</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>compileBracket</code></td>
<td><code>Y(B' S(B'(S(K S))(S(K S))(B' S(K IF)(B' S GEQ K)))(S'(B S(S(K(B S(S(K S))))))(S'(B S(S(K(B S(S(K S))))))(S'(B'(S(K(B'(S(K S)) K S))) K S) K(C' S K SUB1))(C'(B'(S(K(B S K))) S(S(K S)))(C' S K SUB1)(B K K)))(C'(B S(S(K(B'(S(K S)) K S))))(C'(B'(S(K S)) K S)(C' S K SUB1) K)(K K)))) 7 4 2</code></td>
<td>98</td>
</tr>
<tr>
<td><code>compilePlain</code></td>
<td><code>Y(B(S(B S(B(B S)(B(R I)(B(B S)(B(B(B IF))(B(S(B S(B(B GEQ)(B K I))))(B(B K)(B K I)))))))))(S(B S(B(B S)(B(B(B S))(S(B S(B(B S)(B(B(B S))(S(B S(B(B S)(B(B(B S))(B(B(B K))(B(B K)(B K I))))))(B(B(R I))(B(B(B S))(B(R(B K I))(B(B S)(B(B(B S))(R(B(B(B SUB1))(B(B K)(B K I)))(B S(B(B S)(B(B(B S))(B(B(B K))(B(B K)(B K I))))))))))))))))(R(B(B K)(B K I))(B S(B(B S)(B(B(B S))(B(B(R I))(B(B(B S))(B(R(B(B SUB1)(B K I)))(B(B S)(B(B(B S))(B(B(B K))(B(B K)(B K I))))))))))))))))(B(R(B K I))(B(B S)(B(B(B S))(R(B(B K)(B K I))(B S(B(B S)(B(B(B S))(B(B(R(B SUB1 I)))(B(B(B S))(B(B(B K))(B(B K)(B K I)))))))))))))) 7 4 2</code></td>
<td>221</td>
</tr>
<tr>
<td><code>compileK</code></td>
<td><code>Y(B(S(B S(B(B S)(B(R I)(B(B B)(B(B IF)(B(C(B GEQ I)) I)))))))(S(B S(B(B S)(B(B(B S))(S(B S(B(B S)(B(B(B S))(S(B B(B B(B B I)))(B(B(R I))(B(B(B B))(B(R I)(B(B B)(R(B SUB1 I)(B B I))))))))))(R I(B B(B C(B(B C)(B(R I)(B(B B)(R(B SUB1 I)(B B I))))))))))))(B(R I)(B(B B)(B(B C)(R I(B B(B C(R(B SUB1 I)(B B I)))))))))) 7 4 2</code></td>
<td>116</td>
</tr>
<tr>
<td><code>compileEta</code></td>
<td><code>Y(B(S(B S(B(B S)(B(B IF)(C GEQ)))))(S(B S(B(B S)(B(B(B S))(S(B S(B(B S)(B(B(B S))(S(B B(B B B))(R SUB1 B)))))(B C(B(B C)(R SUB1 B)))))))(B(B C)(B C(R SUB1 B))))) 7 4 2</code></td>
<td>58</td>
</tr>
<tr>
<td><code>compileBulk</code></td>
<td><code>Y(B(S3(B2 IF(C GEQ)))(S4(S4(S B3(C C SUB1 B))(B C2(C C SUB1 B)))(B2 C(B C(C C SUB1 B))))) 7 4 2</code></td>
<td>29</td>
</tr>
<tr>
<td><code>compileBulkLinear</code></td>
<td><code>Y(B(B(B S) B(B(B S) B S)(B B B IF(C GEQ)))(B(B S) B(B(B S) B(B(B S) B S))(B(B S) B(B(B S) B(B(B S) B S))(S(B B(B B B))(C C SUB1 B))(B(B(B C) B C)(C C SUB1 B)))(B B B C(B C(C C SUB1 B))))) 7 4 2</code></td>
<td>73</td>
</tr>
<tr>
<td><code>compileBulkLog</code></td>
<td><code>Y(B(B(B(B(B S) B))(S B I)(B(B S) B) I(S B I B IF(C GEQ)))(S B I(S B I(B(B S) B)) I(S B I(S B I(B(B S) B)) I(S(B(B B)(S B I) B)(C C SUB1 B))(B(S B I(B(B C) B) I)(C C SUB1 B)))(S B I B C(B C(C C SUB1 B))))) 7 4 2</code></td>
<td>81</td>
</tr>
</tbody>
</table>
<p>In this example with four variables the trend continues. <code>compileEta</code> produces code is significantly smaller as the baseline. And <code>compileBulk</code> output now is only about 1/3 of the baseline.</p>
<h2 id="executing-bulk-combinators">Executing Bulk Combinators</h2>
<p>We have seen that Kisekyov’s algorithms produce code that makes use of <em>Bulk Combinators</em> like <code>S4</code>, <code>B3</code> or <code>C2</code>. Ben Lynn defines the semantics of these combinators as follows:</p>
<p><img style="align:center;" src="https://latex.codecogs.com/svg.image?\begin{align*}B_{n&plus;1}&=B'B_n\\C_{n&plus;1}&=C'C_n\\S_{n&plus;1}&=S'S_n\end{align*}" /></p>
<p>where <code>B'</code>, <code>C'</code> and <code>S'</code> defined as follows:</p>
<p><img style="align:center;" src="https://latex.codecogs.com/svg.image?\begin{align*}B'&=BB\\C'&=B(BC)B\\S'&=B(BS)B\end{align*}" /></p>
<p>Ben also defines the following function that converts a combinator term with <em>Bulk Combinators</em> to a combinator term with only standard combinators:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">breakBulkLinear ::</span> <span class="dt">Combinator</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CL</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>breakBulkLinear <span class="dt">B</span> n <span class="ot">=</span> <span class="fu">iterate</span> (comB&#39; <span class="op">:@</span>) (<span class="dt">Com</span> <span class="dt">B</span>) <span class="op">!!</span> (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>breakBulkLinear <span class="dt">C</span> n <span class="ot">=</span> <span class="fu">iterate</span> (comC&#39; <span class="op">:@</span>) (<span class="dt">Com</span> <span class="dt">C</span>) <span class="op">!!</span> (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>breakBulkLinear <span class="dt">S</span> n <span class="ot">=</span> <span class="fu">iterate</span> (comS&#39; <span class="op">:@</span>) (<span class="dt">Com</span> <span class="dt">S</span>) <span class="op">!!</span> (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="ot">comB&#39; ::</span> <span class="dt">CL</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>comB&#39; <span class="ot">=</span> <span class="dt">Com</span> <span class="dt">B</span><span class="op">:@</span> <span class="dt">Com</span> <span class="dt">B</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="ot">comC&#39; ::</span> <span class="dt">CL</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>comC&#39; <span class="ot">=</span> <span class="dt">Com</span> <span class="dt">B</span> <span class="op">:@</span> (<span class="dt">Com</span> <span class="dt">B</span> <span class="op">:@</span> <span class="dt">Com</span> <span class="dt">C</span>) <span class="op">:@</span> <span class="dt">Com</span> <span class="dt">B</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="ot">comS&#39; ::</span> <span class="dt">CL</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>comS&#39; <span class="ot">=</span> <span class="dt">Com</span> <span class="dt">B</span> <span class="op">:@</span> (<span class="dt">Com</span> <span class="dt">B</span> <span class="op">:@</span> <span class="dt">Com</span> <span class="dt">S</span>) <span class="op">:@</span> <span class="dt">Com</span> <span class="dt">B</span></span></code></pre></div>
<p>As we have seen in the output of the <code>compileBulkLinear</code> this conversion expands the code size. To avoid this expansion of the combinator code I have implemented a solution to directly execute <em>Bulk Combinators</em> without any prior code expansion.</p>
<p>At the moment I have only implemented this idea in the <a href="https://wiki.haskell.org/wikiupload/0/0a/TMR-Issue10.pdf">Haskell-In-Haskell</a> inspired HHI-Reducer. Implementing it for the Graph Reduction Engine is left as an exercise for the reader ;-).</p>
<p>In order to understand the solution we’ll have a short recap of the HHI-Reducer core ideas <a href="https://thma.github.io/posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html">as described in my last post</a>:</p>
<p>The core idea is to take a combinator term and compile it into a set of Haskell functions. This is done in a function <code>link</code> as follows:</p>
<ol type="1">
<li><p>All combinators of the form <code>(CComb comb)</code> are mapped to haskell functions implementing the respective combinator reduction rule. For example the combinator <code>I</code> is mapped to <code>CFun id</code> and the combinator <code>K</code> is mapped to <code>CFun (CFun . const)</code>.</p></li>
<li><p>All applications <code>(CApp fun arg)</code> have to be replaced by actual function application. In our case we want apply functions of type <code>CExpr -&gt; CExpr</code> that are wrapped by a <code>CFun</code> constructor. For this particular case we define an application operator <code>(!)</code> as follows:</p></li>
</ol>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">0</span> <span class="op">!</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(!) ::</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>(<span class="dt">CFun</span> f) <span class="op">!</span> x <span class="ot">=</span> f x</span></code></pre></div>
<p>Thus:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Cfun</span> <span class="fu">id</span>) <span class="op">!</span> <span class="dv">14</span> <span class="ot">=</span> <span class="fu">id</span> <span class="dv">14</span> </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>         <span class="fu">id</span> <span class="dv">14</span> <span class="ot">=</span> <span class="dv">14</span></span></code></pre></div>
<p>The mapping of Combinators to Haskell functions in step 1. is done by looking up a map of combinator definitions. This map contains definitions for all standard combinators and numeric operations. The Bulk combinators are not defined in this map. Instead they are resolved by the function <code>resolveBulk</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">resolveBulk ::</span> <span class="dt">Combinator</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>resolveBulk (<span class="dt">BulkCom</span> <span class="st">&quot;B&quot;</span> n) <span class="ot">=</span> <span class="fu">iterate</span> (comB&#39; <span class="op">!</span>) comB <span class="op">!!</span> (n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>resolveBulk (<span class="dt">BulkCom</span> <span class="st">&quot;C&quot;</span> n) <span class="ot">=</span> <span class="fu">iterate</span> (comC&#39; <span class="op">!</span>) comC <span class="op">!!</span> (n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>resolveBulk (<span class="dt">BulkCom</span> <span class="st">&quot;S&quot;</span> n) <span class="ot">=</span> <span class="fu">iterate</span> (comS&#39; <span class="op">!</span>) comS <span class="op">!!</span> (n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<p>It’s interesting to note how this functions resembles the <code>breakBulkLinear</code> function. The only difference is that we are using the function application operator <code>(!)</code> instead of the data constructor <code>(:@)</code>.
The function <code>link</code> is now defined as follows:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | &quot;link&quot; a compiled expression into Haskell native functions.</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   application terms will be transformed into real (!) applications</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   combinator symbols will be replaced by their actual function definition</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="ot">link ::</span> <span class="dt">CombinatorDefinitions</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>link definitions (<span class="dt">CApp</span> fun arg) <span class="ot">=</span> link definitions fun <span class="op">!</span> link definitions arg</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>link definitions (<span class="dt">CComb</span> comb)   <span class="ot">=</span> <span class="kw">case</span> <span class="fu">lookup</span> comb definitions <span class="kw">of</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>                                    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> resolveBulk comb</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>                                    <span class="dt">Just</span> e  <span class="ot">-&gt;</span> e</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>link _definitions expr          <span class="ot">=</span> expr</span></code></pre></div>
<p>In the same way I have re-implemented Ben’s function <code>breakBulkLog</code> as <code>resolveBulkLog</code>.</p>
<h2 id="performance-comparison">Performance Comparison</h2>
<p>So far we have seen that for functions with more than two variables the Kiselyov algorithms generate code that is significantly smaller than optimized versions of classic bracket abstraction.
But what about performance? Is the code generated by the Kiselyov algorithms also faster?</p>
<p>To answer this question I have set up a benchmarking suite based on the <a href="http://www.serpentine.com/criterion/">micro-benchmarking framework Criterion</a>.</p>
<p>In my suite I am testing the performance of combinations of the following components:</p>
<ul>
<li>the compilers <code>compileBracket</code>, <code>compileEta</code>, <code>compileBulk</code>, <code>compileBulkLinear</code> and <code>compileBulkLog</code> from the previous section</li>
<li>the function factorial, fibonacci, ackermann and tak from the previous section</li>
<li>the execution backenda Graph Reduction Engine and the HHI-reducer implementaion from my previous post. I have not implemented the Bulk combinators in the graph reduction engine. So I am not testing this backend with the <code>compileBulk</code> compiler.</li>
<li>the HHI-Reducer with both <code>resolveBulkLinear</code> and <code>resolveBulkLog</code></li>
</ul>
<p>So lets start with an overview of the results for the Graph Reduction Backend.</p>
<h3 id="performance-figures-for-the-graph-reduction-engine">Performance figures for the Graph Reduction Engine</h3>
<p>As already mentioned <code>compileBulk</code> is not implemented in the graph reduction engine. I am also not considering the <code>compilePlain</code> and <code>compileK</code> compilers as they generate code that is significantly larger than the baseline.
All durations are given in μs.</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th>execution time [μs]</th>
<th>compileBracket</th>
<th>compileEta</th>
<th>compileBulkLinear</th>
<th>compileBulkLog</th>
</tr>
</thead>
<tbody>
<tr>
<td>factorial</td>
<td>41.34</td>
<td>41.26</td>
<td>41.46</td>
<td>41.45</td>
</tr>
<tr>
<td>fibonacci</td>
<td>107.8</td>
<td>108.4</td>
<td>108.9</td>
<td>113.4</td>
</tr>
<tr>
<td>ackermann</td>
<td>32.22</td>
<td>24.11</td>
<td>25.15</td>
<td>34.27</td>
</tr>
<tr>
<td>tak</td>
<td>194.7</td>
<td>80.18</td>
<td>83.15</td>
<td>102.7</td>
</tr>
</tbody>
</table>
<p>Let’s put these figures into perspective by comparing them to the emitted code size (in number of combinators):</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th>code size [# comb.]</th>
<th>compileBracket</th>
<th>compileEta</th>
<th>compileBulkLinear</th>
<th>compileBulkLog</th>
</tr>
</thead>
<tbody>
<tr>
<td>factorial</td>
<td>13</td>
<td>13</td>
<td>14</td>
<td>14</td>
</tr>
<tr>
<td>fibonacci</td>
<td>27</td>
<td>27</td>
<td>32</td>
<td>36</td>
</tr>
<tr>
<td>ackermann</td>
<td>59</td>
<td>44</td>
<td>64</td>
<td>83</td>
</tr>
<tr>
<td>tak</td>
<td>98</td>
<td>58</td>
<td>73</td>
<td>81</td>
</tr>
</tbody>
</table>
<p>For <code>factorial</code> and <code>fibonacci</code> the code size is very similar for all compilers. And the performance figures are also very similar.</p>
<p>But for <code>ackermann</code> and <code>tak</code> the code size for <code>compileEta</code> is significantly smaller than for the other compilers. An interesting finding here is, that the performance of the <code>compileEta</code> code is significantly better than for the <code>compileBracket</code> code. But the performance of the <code>compileBulkLinear</code> and <code>compileBulkLog</code> code is faster per instruction than the <code>compileBracket</code>and <code>compileEta</code> code.</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th>time / comb. [μs]</th>
<th>compileBracket</th>
<th>compileEta</th>
<th>compileBulkLinear</th>
<th>compileBulkLog</th>
</tr>
</thead>
<tbody>
<tr>
<td>factorial</td>
<td>3.18</td>
<td>3.17</td>
<td>2.96</td>
<td>2.96</td>
</tr>
<tr>
<td>fibonacci</td>
<td>3.99</td>
<td>4.01</td>
<td>3.40</td>
<td>3.15</td>
</tr>
<tr>
<td>ackermann</td>
<td>0.55</td>
<td>0.55</td>
<td>0.39</td>
<td>0.41</td>
</tr>
<tr>
<td>tak</td>
<td>1.99</td>
<td>1.38</td>
<td>1.14</td>
<td>1.27</td>
</tr>
</tbody>
</table>
<p>Overall <code>compileEta</code> gives the best result for the Graph Reduction Engine.</p>
<h3 id="performance-figures-for-the-hhi-reducer">Performance figures for the HHI-Reducer</h3>
<p>first all figures without the Bulk Combinators execution</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th>execution time [μs]</th>
<th>compileBracket</th>
<th>compileEta</th>
<th>compileBulkLinear</th>
<th>compileBulkLog</th>
</tr>
</thead>
<tbody>
<tr>
<td>factorial</td>
<td>14.29</td>
<td>14.30</td>
<td>14.33</td>
<td>14.28</td>
</tr>
<tr>
<td>fibonacci</td>
<td>25.53</td>
<td>25.68</td>
<td>25.88</td>
<td>27.12</td>
</tr>
<tr>
<td>ackermann</td>
<td>10.19</td>
<td>7.309</td>
<td>8.012</td>
<td>10.12</td>
</tr>
<tr>
<td>tak</td>
<td>30.35</td>
<td>21.28</td>
<td>21.81</td>
<td>26.21</td>
</tr>
</tbody>
</table>
<p>The absolute execeution times are significantly smaller than for the Graph Reduction Engine. But the relative performance figures are very similar. Again <code>compileEta</code> gives the best result for the HHI-Reducer. In particular for <code>ackermann</code> and <code>tak</code> the performance of <code>compileEta</code> code is significantly better than for the other compilers.</p>
<h3 id="performance-figures-with-bulk-combinators-execution">Performance figures with Bulk Combinators execution</h3>
<p>Now we want to see whether the native implementation of Bulk Combinators in the HHI-Reducer - <a href="#executing-bulk-combinators">as outlined in the previous section</a> - can beat the performance of the <code>compileEta</code> compilation.</p>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr>
<th>execution time [μs]</th>
<th>compileBracket</th>
<th>compileEta</th>
<th>compileBulk (lin. execution)</th>
<th>compileBulk (log. execution)</th>
<th>compileBulkLinear</th>
<th>compileBulkLog</th>
</tr>
</thead>
<tbody>
<tr>
<td>factorial</td>
<td>14.29</td>
<td>14.30</td>
<td>14.34</td>
<td>14.28</td>
<td>14.33</td>
<td>14.28</td>
</tr>
<tr>
<td>fibonacci</td>
<td>25.53</td>
<td>25.68</td>
<td>25.73</td>
<td>25.91</td>
<td>25.88</td>
<td>27.12</td>
</tr>
<tr>
<td>ackermann</td>
<td>10.19</td>
<td>7.309</td>
<td>7.350</td>
<td>7.349</td>
<td>8.012</td>
<td>10.12</td>
</tr>
<tr>
<td>tak</td>
<td>30.35</td>
<td>21.28</td>
<td>17.90</td>
<td>17.97</td>
<td>21.81</td>
<td>26.21</td>
</tr>
</tbody>
</table>
<p>I see two main findings here:</p>
<ol type="1">
<li><p>For <code>factorial</code>, <code>fibonacci</code> and <code>ackermann</code> the performance of linear and logarithmic execution of Bulk Combinators is not better than the performance of <code>compileEta</code> code.</p>
<p>But for <code>tak</code> the performance of both linear and logarithmic execution of Bulk Combinators is significantly better than the performance of <code>compileEta</code> code. The linear exceution of Bulk Combinators is slightly faster than the logarithmic execution.</p></li>
<li><p>The native implementation of Bulk Combinators is significantly faster than the <code>resolveBulkLinear</code> and <code>resolveBulkLog</code> for <code>ackermann</code> and <code>tak</code>.</p></li>
</ol>
<p>Let’s put these results into perspective by comparing them to the emitted code size (in number of combinators):</p>
<table style="width:100%;">
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr>
<th>code size [# comb.]</th>
<th>compileBracket</th>
<th>compileEta</th>
<th>compileBulk (lin. execution)</th>
<th>compileBulk (log. execution)</th>
<th>compileBulkLinear</th>
<th>compileBulkLog</th>
</tr>
</thead>
<tbody>
<tr>
<td>factorial</td>
<td>13</td>
<td>13</td>
<td>14</td>
<td>14</td>
<td>14</td>
<td>14</td>
</tr>
<tr>
<td>fibonacci</td>
<td>27</td>
<td>27</td>
<td>26</td>
<td>26</td>
<td>32</td>
<td>36</td>
</tr>
<tr>
<td>ackermann</td>
<td>59</td>
<td>44</td>
<td>36</td>
<td>36</td>
<td>64</td>
<td>83</td>
</tr>
<tr>
<td>tak</td>
<td>98</td>
<td>58</td>
<td>29</td>
<td>29</td>
<td>73</td>
<td>81</td>
</tr>
</tbody>
</table>
<ol type="1">
<li><p>For <code>factorial</code> and <code>fibonacci</code> the code size is very similar for all compilers. And the performance figures also don’t vary much.</p>
<p>For <code>ackermann</code> the code size for <code>compileBulk</code> is about 82% of the code size for <code>compileEta</code>. But the execution time is not faster. This is due to the fact that the Bulk Combinator are more complex than the standard combinators. So the execution time per combinator is higher.</p>
<p>For <code>tak</code> the code size for <code>compileBulk</code> is only 50% of the code size for <code>compileEta</code>. The execution time is now 84% of the execution time for <code>compileEta</code>. So even if the execution time per combinator is higher the overall execution time is now lower as the code size is significantly smaller.</p></li>
<li><p>Looking at the code sizes of the <code>compileBulkLinear</code> and <code>compileBulkLog</code> compilers we see that the code size is signifantly larger than for the <code>compileEta</code> and <code>compileBulk</code> compilers for <code>ackermann</code> and <code>tak</code>. So it is now wonder that the execution time is slower than for the `<code>compileEta</code> and <code>compileBulk</code> compilers.</p></li>
</ol>
<h3 id="comparison-to-native-haskell-code">Comparison to native Haskell code</h3>
<p>As a final comparison I have also implemented the factorial, fibonacci, ackermann and tak functions as native Haskell functions. To make the comparison fair I have used a notation using the <code>fix</code> function to implement the Y-Combinator. See for example the implementation of the factorial function:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fact ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>fact <span class="ot">=</span> fix (\f n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n <span class="op">*</span> f (n<span class="op">-</span><span class="dv">1</span>))</span></code></pre></div>
<p>For Graph Reduction Engine I am using the <code>compileEta</code> compiler and for the HHI-Reducer I am using the <code>compileBulk</code> compiler with linear execution of Bulk combinators. The results are as follows:</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr>
<th>execution time [μs]</th>
<th>GraphReduction with compileEta</th>
<th>HHI-Reducer with compileBulk (lin. ex.)</th>
<th>native Haskell</th>
</tr>
</thead>
<tbody>
<tr>
<td>factorial</td>
<td>41.26</td>
<td>14.34</td>
<td>2.776</td>
</tr>
<tr>
<td>fibonacci</td>
<td>108.4</td>
<td>25.73</td>
<td>1.824</td>
</tr>
<tr>
<td>ackermann</td>
<td>24.11</td>
<td>7.350</td>
<td>0.259</td>
</tr>
<tr>
<td>tak</td>
<td>80.18</td>
<td>17.90</td>
<td>0.810</td>
</tr>
</tbody>
</table>
<p>In the following table I’m computing ratios to get simpler comparison metrics:</p>
<table>
<thead>
<tr>
<th>time ratios</th>
<th>ratio GR / HHI</th>
<th>ratio GR/ native</th>
<th>ratio HHI / native</th>
</tr>
</thead>
<tbody>
<tr>
<td>factorial</td>
<td>2.88</td>
<td>14.86</td>
<td>5.17</td>
</tr>
<tr>
<td>fibonacci</td>
<td>4.21</td>
<td>59.43</td>
<td>14.11</td>
</tr>
<tr>
<td>ackermann</td>
<td>3.28</td>
<td>93.12</td>
<td>28.38</td>
</tr>
<tr>
<td>tak</td>
<td>4.48</td>
<td>98.99</td>
<td>22.10</td>
</tr>
</tbody>
</table>
<h2 id="conclusion">Conclusion</h2>
<p>In this post I have shown that the Kiselyov algorithms for compiling SKI combinators to lambda calculus can be used to generate code that is significantly smaller than optimized versions of classic bracket abstraction.</p>
<p>In particular for functions with more than two variables the generation of Bulk-Combinator code avoids the quadratic growth of the code size that is typical for bracket abstraction.</p>
<p>The reduced code size also leads to better performance. In particular for functions with more than two variables the Kiselyov algorithms generate code that is significantly faster than optimized versions of classic bracket abstraction.</p>
<p>I have also shown that the native implementation of Bulk Combinators in the HHI-Reducer can beat the performance of the <code>compileEta</code> compilation. In particular for functions with more than two variables the native implementation of Bulk Combinators is significantly faster.</p>
]]></description>
    <pubDate>Sun, 08 Oct 2023 00:00:00 UT</pubDate>
    <guid>https://thma.github.io//posts/2023-10-08-Optimizing-bracket-abstraction-for-combinator-reduction.html</guid>
    <dc:creator>Thomas Mahler</dc:creator>
</item>
<item>
    <title>Clean Architecture Revisited</title>
    <link>https://thma.github.io//posts/2023-07-29-clean-architecture-revisited.html</link>
    <description><![CDATA[<div class="info">
    <em>Posted on July 29, 2023
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<p><a href="https://github.com/thma/clean-architecture-with-functions/"><img src="https://thma.github.io/img/forkme.png" height="20" ></a></p>
<h2 id="interesting-design-challenges-in-seemingly-simple-programs">Interesting design challenges in seemingly simple programs</h2>
<p>The other day I wrote a simple Haskell program that retrieves data from a REST API and processes it.
The task at hand sounded simple enough to just start coding without too much upfront thinking.</p>
<p>This blog post is about how I discovered the shortcomings of my original design and how I improved it with some simple refactorings.
Since everything interesting happens in the API access, I will focus on this part of the code.</p>
<p>In order to allow you to experiment with the code yourself, I’m not using the proprietary API of my original project but rather a publicly available REST API (<a href="https://openlibrary.org/developers/api">OpenLibrary</a>).</p>
<h2 id="the-original-design">The original design</h2>
<p>So without further ado, let’s start with the domain data types:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Book</span> <span class="ot">=</span> <span class="dt">Book</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> bkTitle   ::</span> <span class="dt">String</span>,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    bkAuthors ::</span> [<span class="dt">String</span>],</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    bkYear    ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Book</span> <span class="kw">where</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  parseJSON (<span class="dt">Object</span> b) <span class="ot">=</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Book</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;$&gt;</span> b <span class="op">.:</span> <span class="st">&quot;title&quot;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;*&gt;</span> b <span class="op">.:?</span> <span class="st">&quot;author_name&quot;</span> <span class="op">.!=</span> []</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;*&gt;</span> b <span class="op">.:?</span> <span class="st">&quot;first_publish_year&quot;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  parseJSON _ <span class="ot">=</span> <span class="fu">mempty</span></span></code></pre></div>
<p>The <code>Book</code> type is a simple record type with a few fields. The <code>FromJSON</code> instance is used to parse the JSON data returned by the REST API.</p>
<p>Next, we need a function to retrieve the data from the REST API. The API allows us to retrieve the data in pages. Each page contains a list of books and the total number of books found. The following function retrieves a single page. The parameters are the query string, the page size and the page number:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getBookPage ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">BookResp</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>getBookPage queryString pageSize pageId <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  request <span class="ot">&lt;-</span> parseRequest <span class="op">$</span> </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    searchUrl <span class="op">++</span> queryString <span class="op">++</span> </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;&amp;page=&quot;</span> <span class="op">++</span> <span class="fu">show</span> pageId <span class="op">++</span> </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;&amp;limit=&quot;</span> <span class="op">++</span> <span class="fu">show</span> pageSize</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  response <span class="ot">&lt;-</span> httpJSON request</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> getResponseBody response</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">BookResp</span> <span class="ot">=</span> <span class="dt">BookResp</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> brDocs  ::</span> [<span class="dt">Book</span>],</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="ot">    brFound ::</span> <span class="dt">Int</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">BookResp</span> <span class="kw">where</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  parseJSON (<span class="dt">Object</span> br) <span class="ot">=</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">BookResp</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;$&gt;</span> br <span class="op">.:</span> <span class="st">&quot;docs&quot;</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;*&gt;</span> br <span class="op">.:</span> <span class="st">&quot;numFound&quot;</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>  parseJSON _ <span class="ot">=</span> <span class="fu">mempty</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="ot">searchUrl ::</span> <span class="dt">String</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>searchUrl <span class="ot">=</span> <span class="st">&quot;http://openlibrary.org/search.json?q=&quot;</span></span></code></pre></div>
<p>Based on this function which retrieves a single page, we can write a function which retrieves all pages:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">searchBooks ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Book</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>searchBooks pageSize limitPages queryString <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  firstPage <span class="ot">&lt;-</span> getBookPage queryString pageSize <span class="dv">1</span> <span class="co">-- index starts at 1 !</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> numOfBooks <span class="ot">=</span> brFound firstPage</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>      numPages <span class="ot">=</span> <span class="fu">min</span> (numOfBooks <span class="ot">`div`</span> pageSize <span class="op">+</span> <span class="dv">1</span>) limitPages</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>      otherPages <span class="ot">=</span> </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> numPages <span class="op">==</span> <span class="dv">1</span> </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>          <span class="kw">then</span> [] </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> <span class="fu">map</span> (getBookPage queryString pageSize) [<span class="dv">1</span> <span class="op">..</span> numPages]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  allPages <span class="ot">&lt;-</span> (firstPage <span class="op">:</span>) <span class="op">&lt;$&gt;</span> <span class="fu">sequence</span> otherPages</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">concatMap</span> brDocs allPages</span></code></pre></div>
<p>The <code>searchBooks</code> function takes a page size, a limit for the number of pages and a query string.
It then retrieves all pages and concatenates the books from all pages into a single list.</p>
<p>Now we have all the pieces in place to write the main function:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- search for books with &quot;Haskell Curry&quot; in title or author fields, </span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- limit to 10 pages of 50 books each (== 500 books)</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  books <span class="ot">&lt;-</span> searchBooks <span class="dv">50</span> <span class="dv">10</span> <span class="st">&quot;Haskell Language&quot;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Number of matching books: &quot;</span> <span class="op">++</span> <span class="fu">show</span> (<span class="fu">length</span> books)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM_</span> (<span class="fu">putStrLn</span> <span class="op">.</span> bkTitle) books</span></code></pre></div>
<p>This will print the number of books found and their respective titles.</p>
<pre><code>Number of matching books: 34</code></pre>
<p>A quick manual check on the Open Library website confirms that the number of books found is indeed correct.</p>
<p>That was is easy, wasn’t it? But wait, let’s have a closer look by changing the page size…</p>
<h2 id="its-just-an-off-by-one-error">It’s just an off-by-one error…</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- search for books with &quot;Haskell Curry&quot; in title or author fields, </span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- limit to 10 pages of 10 books each (== 100 books)</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  books <span class="ot">&lt;-</span> searchBooks <span class="dv">10</span> <span class="dv">10</span> <span class="st">&quot;Haskell Language&quot;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Number of matching books: &quot;</span> <span class="op">++</span> <span class="fu">show</span> (<span class="fu">length</span> books)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM_</span> (<span class="fu">putStrLn</span> <span class="op">.</span> bkTitle) books</span></code></pre></div>
<p>Now we get the following output:</p>
<pre><code>Number of matching books: 44</code></pre>
<p>What happened here? Instead of the correct number of 34 books we now get 44 books returned.
It seems that this was caused by the changing the page size. As we get exactly 10 books more as expected it seems that we get one page more than we asked for.</p>
<p>So let’s have a closer look at the <code>searchBooks</code> function.
It starts by retrieving the first page which also contains the total number of found books.
This value is bound to the <code>numOfBooks</code> variable.
Next the total number of pages is calculated by dividing the number of books by the page size and adding 1.
By binding the minimum of this value and the limit for the number of pages to the <code>numPages</code> variable, we ensure that we don’t retrieve more pages than we asked for.
Finally, the <code>otherPages</code> variable is bound to a list of all pages except the first page.</p>
<p>And here we have our off-by-one error. The list comprehension should start at 2 instead of 1:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">searchBooks ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Book</span>]</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>searchBooks pageSize limitPages queryString <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  firstPage <span class="ot">&lt;-</span> getBookPage queryString pageSize <span class="dv">1</span> <span class="co">-- index starts at 1 !</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> numOfBooks <span class="ot">=</span> brFound firstPage</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>      numPages <span class="ot">=</span> <span class="fu">min</span> (numOfBooks <span class="ot">`div`</span> pageSize <span class="op">+</span> <span class="dv">1</span>) limitPages</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>      otherPages <span class="ot">=</span> </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> numPages <span class="op">==</span> <span class="dv">1</span> </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>          <span class="kw">then</span> [] </span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> <span class="fu">map</span> (getBookPage queryString pageSize) [<span class="dv">2</span> <span class="op">..</span> numPages]</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  allPages <span class="ot">&lt;-</span> (firstPage <span class="op">:</span>) <span class="op">&lt;$&gt;</span> <span class="fu">sequence</span> otherPages</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">concatMap</span> brDocs allPages</span></code></pre></div>
<p>This finding seems to be a perfect fit for the following quote:</p>
<blockquote>
<p>There are only two hard problems in computer science:</p>
<ol start="0" type="1">
<li>cache invalidation</li>
<li>naming things.</li>
<li>off-by-one errors</li>
</ol>
</blockquote>
<h2 id="do-as-i-say-not-as-i-do.">Do as I say, not as I do.</h2>
<p>At this point I felt a bit uncomfortable as I realized that I should have written some unit tests to catch this error. Or even better to start with the tests and then write the code.</p>
<p>If you have read some of my other blog posts, you might have noticed that I’m a big fan of unit testing and property based testing in particular.
So why didn’t I write any tests for this code?</p>
<p>The answer is simple: <code>searchBooks</code> is directly coupled to the page access function <code>getBookPage</code>.
All unit tests for <code>searchBooks</code> would interact directly with the real openlibrary API. This would render the tests unstable as the API could be offline or give different results over time.</p>
<p>So what can we do about this? We need to decouple the <code>searchBooks</code> function from the <code>getBookPage</code> function. Functional programming offers us a simple solution for this problem: <em>higher order functions</em>. In this case: allowing to pass the page access function as a parameter to <code>searchBooks</code>.</p>
<h2 id="from-cruft-to-craft">From cruft to craft</h2>
<p>In this section we will refactor the code to allow passing the page access function as a parameter to <code>searchBooks</code>.
Let’s start by defining a type for the page access function. I have also changed the <code>Int</code> parameters to <code>Natural</code> as I don’t want to allow negative page sizes and offsets.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">PageAccess</span> <span class="ot">=</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">BookResp</span></span></code></pre></div>
<p>Next we will change the signature of <code>getBookPage</code> to match this type:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getBookPage ::</span> <span class="dt">PageAccess</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>getBookPage queryString pageSize pageId <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  request <span class="ot">&lt;-</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    parseRequest <span class="op">$</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>      searchUrl</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span> queryString</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span> <span class="st">&quot;&amp;page=&quot;</span>  <span class="op">++</span> <span class="fu">show</span> pageId</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span> <span class="st">&quot;&amp;limit=&quot;</span> <span class="op">++</span> <span class="fu">show</span> pageSize</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  response <span class="ot">&lt;-</span> httpJSON request</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> getResponseBody response</span></code></pre></div>
<p>Finally we will rewrite <code>searchBooks</code> to have an additional parameter of type <code>PageAccess</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">searchBooks ::</span> <span class="dt">PageAccess</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Book</span>]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>searchBooks bookPageFun pageSize limitPages queryString <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  firstPage <span class="ot">&lt;-</span> bookPageFun queryString pageSize <span class="dv">1</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> numOfBooks <span class="ot">=</span> brFound firstPage</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>      numPages <span class="ot">=</span> <span class="fu">min</span> (numOfBooks <span class="ot">`div`</span> pageSize <span class="op">+</span> <span class="dv">1</span>) limitPages</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>      otherPages <span class="ot">=</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> numPages <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>          <span class="kw">then</span> []</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> <span class="fu">map</span> (bookPageFun queryString pageSize) [<span class="dv">2</span> <span class="op">..</span> numPages]</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  allPages <span class="ot">&lt;-</span> (firstPage <span class="op">:</span>) <span class="op">&lt;$&gt;</span> <span class="fu">sequence</span> otherPages</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">concatMap</span> brDocs allPages</span></code></pre></div>
<p>This simple change allows us to use <code>searchBooks</code> with different page access functions.
The main function now looks like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- search for books with &quot;Haskell Curry&quot; in title or author fields, </span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- limit to 10 pages of 10 books each (== 100 books)</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> openLibrarySearch <span class="ot">=</span> searchBooks getBookPage <span class="dv">10</span> <span class="dv">10</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  books <span class="ot">&lt;-</span> openLibrarySearch <span class="st">&quot;Haskell Curry&quot;</span> </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Number of matching books: &quot;</span> <span class="op">++</span> <span class="fu">show</span> (<span class="fu">length</span> books)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM_</span> (<span class="fu">putStrLn</span> <span class="op">.</span> bkTitle) books</span></code></pre></div>
<h2 id="finally-some-unit-tests">Finally, some unit tests</h2>
<p>We can now use this decoupling to pass a mock page access function to <code>searchBooks</code> in order to write unit tests for it.
Let’s start by writing a mock page access which returns a specified number of books:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A mock implementation of the book page access function.</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   The argument resultCount specifies the total number of books to return.</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="ot">mockBookPageImpl ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">PageAccess</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>mockBookPageImpl _ _ _ <span class="dv">0</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;pageId must be &gt;= 1&quot;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>mockBookPageImpl resultCount _queryString pageSize pageId <span class="ot">=</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (numFullPages, remainder) <span class="ot">=</span> resultCount <span class="ot">`quotRem`</span> pageSize</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>      numPages <span class="ot">=</span> <span class="kw">if</span> remainder <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> numFullPages <span class="kw">else</span> numFullPages <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span>  <span class="kw">if</span> pageId <span class="op">&lt;=</span> numFullPages</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">BookResp</span> (<span class="fu">replicate</span> (<span class="fu">fromIntegral</span> pageSize) sampleBook) resultCount</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">if</span> remainder <span class="op">/=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> pageId <span class="op">==</span> numPages</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>          <span class="kw">then</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">BookResp</span> (<span class="fu">replicate</span> (<span class="fu">fromIntegral</span> remainder) sampleBook) resultCount</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">BookResp</span> [] resultCount</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="ot">sampleBook ::</span> <span class="dt">Book</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>sampleBook <span class="ot">=</span> <span class="dt">Book</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>  { bkTitle <span class="ot">=</span> <span class="st">&quot;The Lord of the Rings&quot;</span>,</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    bkAuthors <span class="ot">=</span> [<span class="st">&quot;J. R. R. Tolkien&quot;</span>],</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    bkYear <span class="ot">=</span> <span class="dt">Just</span> <span class="dv">1954</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Now we can start to write unit tests for <code>searchBooks</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">spec ::</span> <span class="dt">Spec</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>spec <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  describe <span class="st">&quot;Using a paging backend API as data input&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    it <span class="st">&quot;works for empty result&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> mockSearch <span class="ot">=</span> searchBooks (mockBookPageImpl <span class="dv">0</span>) <span class="dv">50</span> <span class="dv">10</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>      result <span class="ot">&lt;-</span> mockSearch <span class="st">&quot;Harry Potter&quot;</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>      <span class="fu">length</span> result <span class="ot">`shouldBe`</span> <span class="dv">0</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    it <span class="st">&quot;respects the max number of pages parameter&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> mockSearch <span class="ot">=</span> searchBooks (mockBookPageImpl <span class="dv">100</span>) <span class="dv">5</span> <span class="dv">10</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>      result <span class="ot">&lt;-</span> mockSearch <span class="st">&quot;Harry Potter&quot;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>      <span class="fu">length</span> result <span class="ot">`shouldBe`</span> <span class="dv">50</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    it <span class="st">&quot;works correctly in the last page&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> mockSearch <span class="ot">=</span> searchBooks (mockBookPageImpl <span class="dv">49</span>) <span class="dv">5</span> <span class="dv">10</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>      result <span class="ot">&lt;-</span> mockSearch <span class="st">&quot;Harry Potter&quot;</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>      <span class="fu">length</span> result <span class="ot">`shouldBe`</span> <span class="dv">49</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    it <span class="st">&quot;can deal with arbitrary result sizes&quot;</span> <span class="op">$</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>      property <span class="op">$</span> \resultSize <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> mockSearch <span class="ot">=</span> searchBooks (mockBookPageImpl resultSize) <span class="dv">5</span> <span class="dv">10</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>        result <span class="ot">&lt;-</span> mockSearch <span class="st">&quot;Harry Potter&quot;</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>        <span class="fu">length</span> result <span class="ot">`shouldBe`</span> <span class="fu">fromIntegral</span> (<span class="fu">min</span> resultSize <span class="dv">50</span>)</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    it <span class="st">&quot;can deal with arbitrary page sizes&quot;</span> <span class="op">$</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>      property <span class="op">$</span> \ps <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> pageSize <span class="ot">=</span> ps <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>            mockSearch <span class="ot">=</span> searchBooks (mockBookPageImpl <span class="dv">100</span>) pageSize <span class="dv">10</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>        result <span class="ot">&lt;-</span> mockSearch <span class="st">&quot;Harry Potter&quot;</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>        <span class="fu">length</span> result <span class="ot">`shouldBe`</span> <span class="fu">fromIntegral</span> (<span class="fu">min</span> <span class="dv">100</span> (pageSize <span class="op">*</span> <span class="dv">10</span>))</span></code></pre></div>
<p>which results in the following output:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">SearchBooks</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="ex">Using</span> a paging backend API as data input</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">works</span> for empty result <span class="pp">[</span><span class="ss">✔</span><span class="pp">]</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="ex">respects</span> the max number of pages parameter <span class="pp">[</span><span class="ss">✔</span><span class="pp">]</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">works</span> correctly in the last page <span class="pp">[</span><span class="ss">✔</span><span class="pp">]</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="ex">can</span> deal with arbitrary result sizes <span class="pp">[</span><span class="ss">✔</span><span class="pp">]</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>      <span class="ex">+++</span> OK, passed 100 tests.</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="ex">can</span> deal with arbitrary page sizes <span class="pp">[</span><span class="ss">✔</span><span class="pp">]</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>      <span class="ex">+++</span> OK, passed 100 tests.</span></code></pre></div>
<p>So now we have a unit test suite for <code>searchBooks</code> which doesn’t depend on the real API. This was made possible by decoupling the page access function from <code>searchBooks</code>.</p>
<h2 id="decoupling-and-clean-architecture">Decoupling and Clean Architecture</h2>
<p>In order to illustrate the decoupling achieved by this refactoring, I have created a dependency graph of the modules involved. The arrows indicate the direction of the dependencies. The <code>searchBooks</code> function (in the <code>SearchUseCase</code> module) does only depend on the <code>PageAccess</code> type (in the <code>ApiModel</code> module) and of course on the <code>Book</code> type in the <code>DomainModel</code> module.</p>
<p>The <code>Main</code> module takes the <code>getBookPage</code> function (from module <code>ApiAccess</code>) and passes it to the <code>searchBooks</code> function in order to work against the real API.
<code>getBookPage</code> only depends on the <code>PageAccess</code> type.</p>
<figure>
<img src="../img/dependencies-with-functions.png" alt="dependencies" />
<figcaption aria-hidden="true">dependencies</figcaption>
</figure>
<p>(Generated with <a href="https://hackage.haskell.org/package/graphmod">GraphMod</a>)</p>
<p>This is exactly the kind of decoupling that the <a href="https://thma.github.io/posts/2020-05-29-polysemy-clean-architecture.html">clean architecture</a> advocates:</p>
<blockquote>
<p>The overriding rule that makes this architecture work is The Dependency Rule.
This rule says that source code dependencies can only point inwards.
Nothing in an inner circle can know anything at all about something in an outer circle.
In particular, the name of something declared in an outer circle must not be mentioned by the code in the an inner circle.
That includes, functions, classes. variables, or any other named software entity.</p>
<p>Quoted from <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture blog post</a></p>
</blockquote>
<figure>
<img src="../img/clean-architecture-with-functions.png" alt="clean architecture" />
<figcaption aria-hidden="true">clean architecture</figcaption>
</figure>
<p>I hope that this post has shown you that the clean architecture is not only applicable to large projects. Even in very small projects it can help to decouple business logic from infrastructure code and thus greatly improve testability.</p>
<p>Luckily for us Haskell programmers, we don’t need to use any frameworks to achieve this decoupling. We can use higher order functions to achieve the same result.</p>
]]></description>
    <pubDate>Sat, 29 Jul 2023 00:00:00 UT</pubDate>
    <guid>https://thma.github.io//posts/2023-07-29-clean-architecture-revisited.html</guid>
    <dc:creator>Thomas Mahler</dc:creator>
</item>
<item>
    <title>Writing a Haskell persistence layer using Generics and Reflection</title>
    <link>https://thma.github.io//posts/2023-01-21-a-haskell-persistence-layer-using-generics-and-reflection.html</link>
    <description><![CDATA[<div class="info">
    <em>Posted on January 21, 2023
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<!--
[![Actions Status](https://github.com/thma/generic-persistence/workflows/Haskell%20CI/badge.svg)](https://github.com/thma/generic-persistenceactions)
-->
<p><a href="https://github.com/thma/generic-persistence/tree/archive-blog-post-2023-01-23"><img src="https://thma.github.io/img/forkme.png" height="20" ></a></p>
<h2 id="abstract">Abstract</h2>
<p>In this post I’ll describe how to write a minimalistic Haskell persistence layer (on top of HDBC).
My approach will rely heavily on Generics (<code>Data.Data</code>, <code>Data.Typeable</code>) and Reflection (<code>Type.Reflection</code>).</p>
<p>The design goal is to avoid any boilerplate code.</p>
<p><strong>Please note:</strong> I received some helpful feedback on this post. I have now updated the code to reflect the suggestions.
So the code in this post is now outdated. Please refer to the <a href="https://github.com/thma/generic-persistence/">GitHub repository</a> for the latest version.</p>
<h2 id="introduction">Introduction</h2>
<p>The <em>functional goal</em> of my persistence layer is to provide hassle-free RDBMS persistence for Haskell data types in
Record notation (for brevity I call them <em>Entities</em>).</p>
<p>That is, it must provide means for inserting, updating, deleting and quering such enties to/from relational databases.</p>
<p>Not in scope for the current state of the library are things like:</p>
<ul>
<li>A query language</li>
<li>User-definable mappings of Haskell types to RDBMS types</li>
<li>Handling of relationships between entities (1:1, 1:n, n:m)</li>
<li>Handling of transactions</li>
<li>Handling of database migrations</li>
<li>Handling of database schemas</li>
<li>Handling of database connections and sessions</li>
<li>Handling of prepared statements</li>
<li>Handling auto-incrementing primary keys</li>
<li>Caching</li>
<li>…</li>
</ul>
<p>So as of now it’s just about the bare minimum to get some data into a database and to get it back out again.</p>
<p>The main <em>design goal</em> is to minimize the <em>boilerplate</em> code required. Ideally I would like to achieve the following:</p>
<ul>
<li>no manual instantiation of type classes</li>
<li>no implementation of encoders/decoders</li>
<li>no special naming convention for types and their attributes</li>
<li>no special types to define entities and attributes</li>
<li>no Template Haskell scaffolding of glue code</li>
</ul>
<p>In an ideal world we would be able to take any POHO (Plain old Haskell Object)
and persist it to any RDBMS without any additional effort.</p>
<h2 id="short-demo">Short demo</h2>
<p>Here now follows a short demo that shows how the library looks and feels from the user’s point of view.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable#-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Data</span> ( <span class="dt">Data</span> )</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">TypeInfo</span> ( typeInfo ) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GenericPersistence</span>( delete, persist, retrieveAll, retrieveById )</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Database.HDBC</span> (disconnect, runRaw, commit) </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Database.HDBC.Sqlite3</span> ( connectSqlite3 )</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- | define a data type with several fields, using record syntax.</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">Person</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> personID ::</span> <span class="dt">Int</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> name ::</span> <span class="dt">String</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> age ::</span> <span class="dt">Int</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> address ::</span> <span class="dt">String</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Data</span>)</span></code></pre></div>
<p>The persistent data type must be deriving the <code>Data.Data</code> type class. This is required
to enable all the Generics magic to work behind the scenes.
Fortunately, deriving <code>Data</code> needs no manual implementation, we get it for free by enabling <code>DeriveDataTypeable</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- initialize Person table</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    conn <span class="ot">&lt;-</span> connectSqlite3 <span class="st">&quot;sqlite.db&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    runRaw conn <span class="st">&quot;DROP TABLE IF EXISTS Person;&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    runRaw conn <span class="st">&quot;CREATE TABLE IF NOT EXISTS Person (personID INT PRIMARY KEY, name TEXT, age INT, address TEXT);&quot;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    commit conn</span></code></pre></div>
<p>As of now my library does not cover the creation of database tables. So this is still a manual step.
As already mentioned, the library does not cover any user defined mapping of data type attributes to columns.
As of now the same names for the attributes and the columns are used.
For the column types we are choosing types that can be automatically converted by HDBC.</p>
<p>Now we move on to using the actual library functions:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- create a Person entity</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> alice <span class="ot">=</span> <span class="dt">Person</span> {personID <span class="ot">=</span> <span class="dv">123456</span>, name <span class="ot">=</span> <span class="st">&quot;Alice&quot;</span>, age <span class="ot">=</span> <span class="dv">25</span>, address <span class="ot">=</span> <span class="st">&quot;Elmstreet 1&quot;</span>}</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- insert a Person into a database</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    persist conn alice</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- update a Person</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    persist conn alice {address <span class="ot">=</span> <span class="st">&quot;Main Street 200&quot;</span>}  </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- select a Person from a database</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- The result type must be provided explicitly, as `retrieveById` has a polymorphic return type `IO a`.</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    alice&#39; <span class="ot">&lt;-</span> retrieveById conn <span class="st">&quot;123456&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">Person</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- delete a Person from a database</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    delete conn alice&#39;</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- close connection</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    disconnect conn</span></code></pre></div>
<p>And here comes the output of the demo program. As you can see, there is some trace output for each of the database operations.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> main</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Inserting</span> <span class="dt">Person</span> <span class="dv">123456</span> <span class="st">&quot;Alice&quot;</span> <span class="dv">25</span> <span class="st">&quot;Elmstreet 1&quot;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Updating</span> <span class="dt">Person</span> <span class="dv">123456</span> <span class="st">&quot;Alice&quot;</span> <span class="dv">25</span> <span class="st">&quot;Main Street 200&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Retrieve</span> <span class="dt">Person</span> with <span class="fu">id</span> <span class="dv">123456</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Deleting</span> <span class="dt">Person</span> with <span class="fu">id</span> <span class="dv">123456</span></span></code></pre></div>
<p>Summarizing, we can state that there is virtually no boilerplate code required in the user code.
The only thing we have to do is to derive the <code>Data</code> type class for our persistent data types.
The library takes care of the rest.</p>
<h2 id="a-deeper-dive-into-the-library">A deeper dive into the library</h2>
<h3 id="the-persist-function">The <code>persist</code> function</h3>
<p>In this section we are taking a closer look at the library internals. Let’s start with the <code>persist</code> function:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that persists an entity  to a database.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- The function takes an HDBC connection and an entity as parameters.</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- The entity is either inserted or updated, depending on whether it already exists in the database.</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- The required SQL statements are generated dynamically using Haskell generics and reflection</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="ot">persist ::</span> (<span class="dt">IConnection</span> conn, <span class="dt">Data</span> a) <span class="ot">=&gt;</span> conn <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>persist conn entity <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  resultRows <span class="ot">&lt;-</span> quickQuery conn selectStmt []</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> resultRows <span class="kw">of</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>      trace <span class="op">$</span> <span class="st">&quot;Inserting &quot;</span> <span class="op">++</span> gshow entity</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>      runRaw conn insertStmt</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>      commit conn</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    [_singleRow] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>      trace <span class="op">$</span> <span class="st">&quot;Updating &quot;</span> <span class="op">++</span> gshow entity</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>      runRaw conn updateStmt</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>      commit conn</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;More than one entity found for id &quot;</span> <span class="op">++</span> <span class="fu">show</span> eid</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    ti <span class="ot">=</span> typeInfo entity</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    eid <span class="ot">=</span> entityId entity</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    selectStmt <span class="ot">=</span> selectStmtFor ti eid</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    insertStmt <span class="ot">=</span> insertStmtFor entity</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    updateStmt <span class="ot">=</span> updateStmtFor entity</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns the primary key value of an entity as a String.    </span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="ot">entityId ::</span> <span class="kw">forall</span> d<span class="op">.</span> (<span class="dt">Data</span> d) <span class="ot">=&gt;</span> d <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>entityId x <span class="ot">=</span> fieldValueAsString x (idColumn (typeInfo x))</span></code></pre></div>
<p>The overall logic of this function is as follows:</p>
<ol type="1">
<li>Perform a select query against the table corresponding to type <code>a</code> to check whether a record is already present for the primary key value derived from <code>entity</code>.</li>
<li>If the list of resulting rows is empty, the entity has not been persisted before and an <code>INSERT</code>-statement has to be excecuted.</li>
<li>If the list contains exactly one row, the entity already was stored in the DB and an <code>UPDATE</code>-statement has to be executed.</li>
<li>If the list contains more than one row, something is wrong and an error is thrown.</li>
</ol>
<p>The <code>selectStmtFor</code>, <code>insertStmtFor</code> and <code>updateStmtFor</code> functions are used to generate the required SQL statements dynamically.</p>
<h4 id="inserting-an-entity">Inserting an entity</h4>
<p>Let’s start with <code>insertStmtFor</code> as it is the simplest one.</p>
<p>Let’s say we have a Person entity:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alice ::</span> <span class="dt">Person</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>alice <span class="ot">=</span> <span class="dt">Person</span> {personID <span class="ot">=</span> <span class="dv">123456</span>, name <span class="ot">=</span> <span class="st">&quot;Alice&quot;</span>, age <span class="ot">=</span> <span class="dv">25</span>, address <span class="ot">=</span> <span class="st">&quot;Elmstreet 1&quot;</span>}</span></code></pre></div>
<p>Then the corresponding insert statement is:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">INSERT</span> <span class="kw">INTO</span> Person (<span class="kw">id</span>, name, age, address) <span class="kw">VALUES</span> (<span class="dv">123456</span>, <span class="ot">&quot;Alice&quot;</span>, <span class="dv">25</span>, <span class="ot">&quot;Elmstreet 1&quot;</span>);</span></code></pre></div>
<p>So in order to generate the insert statement we need to know the table name, the column names and the values.
The idea is to use Haskell Generics to obtain these from the entity instance.
As of now I’m using the type- and attribute-names directly as column names. But this could be easily changed later on.
The tricky business is to dynamically inspect the entity instance and extract the values of the attributes.</p>
<p>So here comes the code for <code>insertStmtFor</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">insertStmtFor ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>insertStmtFor x <span class="ot">=</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;INSERT INTO &quot;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> typeName x</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; (&quot;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> intercalate <span class="st">&quot;, &quot;</span> (fieldNames x)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;) VALUES (&quot;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> intercalate <span class="st">&quot;, &quot;</span> (fieldValues x)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;);&quot;</span></span></code></pre></div>
<p>The overall construction of the insert statement is obvious. We just need to know a bit more about the <code>typeName</code>, <code>fieldNames</code> and <code>fieldValues</code> functions from the <code>TypeInfo</code> module:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns the (unqualified) type name of an entity.</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ot">typeName ::</span> (<span class="dt">Data</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>typeName <span class="ot">=</span> dataTypeName <span class="op">.</span> dataTypeOf</span></code></pre></div>
<p>The <code>typeName</code> function uses the <code>dataTypeOf :: a -&gt; DataType</code> function of the <code>Data</code>type class to obtain the type of a <code>Data</code>instance.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that take an entity as input paraemeter and returns a list of </span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   Strings representing the values of all fields of the entity.</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   Example: fieldValues (Person &quot;John&quot; 42) = [&quot;John&quot;, &quot;42&quot;]</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fieldValues ::</span> (<span class="dt">Data</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>fieldValues <span class="ot">=</span> gmapQ gshow</span></code></pre></div>
<p>The function <code>fieldValues</code> is a bit more tricky. It uses the <code>gmapQ</code> function from the <code>Data.Data</code> module to map the <code>gshow</code> function over all attributes of the entity. The <code>gshow</code> function is a generic version of the <code>show</code> function that works on any <code>Data</code> instance.
If you want to know more about <code>gmapQ</code> and <code>gshow</code>, you can read Chris Done’s <a href="https://chrisdone.com/posts/data-typeable/">Typeable and Data in Haskell</a>.</p>
<p>To understand the <code>fieldNames</code> function, we need to take a look at <code>TypeInfo</code> and <code>FieldInfo</code> first:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A data type that holding information about a type. The Phantom type parameter `a` ensures type safety.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TypeInfo</span> a <span class="ot">=</span> <span class="dt">TypeInfo</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  { <span class="co">-- | The constructors of the type.</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    typeConstructor ::</span> <span class="dt">Constr</span>,</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- | The fields of the type.</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    typeFields      ::</span> [<span class="dt">FieldInfo</span>]</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A data type that holds information about a field of a data type.</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FieldInfo</span> <span class="ot">=</span> <span class="dt">FieldInfo</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>  { <span class="co">-- | The name of the field, Nothing if it has none.</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    fieldName        ::</span> <span class="dt">Maybe</span> <span class="dt">String</span>,</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- | The constructor of the field.</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="ot">    fieldConstructor ::</span> <span class="dt">Constr</span>,</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- | The type of the field.</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    fieldType        ::</span> <span class="dt">TypeRep</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)  </span></code></pre></div>
<p>A <code>TypeInfo</code> can be obtained from an entity using the <code>typeInfo</code> function:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typeInfo ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">TypeInfo</span> a</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>typeInfo x <span class="ot">=</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TypeInfo</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    { typeConstructor <span class="ot">=</span> toConstr x,</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      typeFields <span class="ot">=</span> fieldInfo x</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>Where <code>toConstr :: a -&gt; Constr</code> is a function from the <code>Data</code> type class that returns the constructor of a <code>Data a</code> instance; and
<code>fieldInfo</code> is a function that returns the list of <code>FieldInfo</code> instances for a given entity:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns a list of FieldInfos representing the name, constructor and type of each field in the data type `a`.</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">fieldInfo ::</span> (<span class="dt">Data</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">FieldInfo</span>]</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>fieldInfo x <span class="ot">=</span> <span class="fu">zipWith3</span> <span class="dt">FieldInfo</span> names constrs types</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    constructor <span class="ot">=</span> toConstr x</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    candidates <span class="ot">=</span> constrFields constructor</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    constrs <span class="ot">=</span> gmapQ toConstr x</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    types <span class="ot">=</span> gmapQ typeOf x</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    names ::</span> [<span class="dt">Maybe</span> <span class="dt">String</span>] <span class="ot">=</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> <span class="fu">length</span> candidates <span class="op">==</span> <span class="fu">length</span> constrs</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> <span class="fu">map</span> <span class="dt">Just</span> candidates</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="fu">replicate</span> (<span class="fu">length</span> constrs) <span class="dt">Nothing</span></span></code></pre></div>
<p>The <code>fieldInfo</code> function uses the <code>constrFields :: Constr -&gt; [String]</code> function from the <code>Data</code> type class to obtain the names of the fields of the constructor of the entity. If type <code>a</code> is a record type, the names of the fields are returned. Otherwise an empty list is returned.
This list of candidate field names then used to create a list <code>names</code> of <code>Maybe String</code> values . If the length of the candidate list is equal to the length of the list of actual field constructors, the entity is a record type and the candidate names are used. Otherwise the list of names is filled with <code>Nothing</code> values.</p>
<p>The <code>gmapQ</code> function is used to map the <code>toConstr</code> and <code>typeOf</code> functions over the entity to obtain the constructors and types of the fields.</p>
<p>Finally the <code>zipWith3</code> function is used to combine the three lists into a list of <code>FieldInfo</code> instances.</p>
<p>Now back to the <code>fieldNames</code> function:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns the list of field names of an entity of type `a`.  </span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ot">fieldNames ::</span> (<span class="dt">Data</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>fieldNames <span class="ot">=</span> fieldNamesFromTypeInfo <span class="op">.</span> typeInfo</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns the list of field names of a `TypeInfo a` object.</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">--   An error is thrown if the type does not have named fields.</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="ot">fieldNamesFromTypeInfo ::</span> <span class="dt">TypeInfo</span> a <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>fieldNamesFromTypeInfo ti <span class="ot">=</span> <span class="fu">map</span> (expectJust errMsg <span class="op">.</span> fieldName) (typeFields ti)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    errMsg <span class="ot">=</span> <span class="st">&quot;Type &quot;</span> <span class="op">++</span> tiTypeName ti <span class="op">++</span> <span class="st">&quot; does not have named fields&quot;</span></span></code></pre></div>
<p>The <code>fieldNames</code> function uses the <code>typeInfo</code> function to obtain the <code>TypeInfo</code> instance for the entity and then maps the <code>fieldNamesFromTypeInfo</code> function over all type fields to obtain the list of field names.</p>
<p>This is all tooling that we need to generate the insert statement for an entity by dynamically inspecting its type information. This statement is then used to insert the entity into the database by using the HDBC API.</p>
<h4 id="updating-an-entity">Updating an entity</h4>
<p>The update statement is generated in a similar way. The only difference is that we need to know the primary key of the entity in order to generate the <code>WHERE</code> clause of the update statement.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns an SQL update statement for an entity. Type &#39;a&#39; must be an instance of Data.</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">updateStmtFor ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>updateStmtFor x <span class="ot">=</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;UPDATE &quot;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> typeName x</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; SET &quot;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> intercalate <span class="st">&quot;, &quot;</span> updatePairs</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; WHERE &quot;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> idColumn ti</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; = &quot;</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> fieldValueAsString x (idColumn ti)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;;&quot;</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    updatePairs <span class="ot">=</span> <span class="fu">zipWith</span> (\n v <span class="ot">-&gt;</span> n <span class="op">++</span> <span class="st">&quot; = &quot;</span> <span class="op">++</span> v) (fieldNames x) (fieldValues x)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    ti <span class="ot">=</span> typeInfo x</span></code></pre></div>
<p>The primary key column is obtained using the <code>idColumn</code> function:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns the name of the primary key column for a type &#39;a&#39;.</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co">--  By convention we are using the following name: convert the type name to lower case and append &quot;ID&quot;.</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ot">idColumn ::</span> <span class="dt">TypeInfo</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>idColumn ti <span class="ot">=</span> <span class="fu">map</span> <span class="fu">toLower</span> (tiTypeName ti) <span class="op">++</span> <span class="st">&quot;ID&quot;</span></span></code></pre></div>
<p>The <code>fieldValueAsString</code> function takes an entity and a field name as input parameters and returns the value of the field as a String:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that takes an entity and a field name as input parameters and returns the value of the field as a String.</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">--  Example: fieldValueAsString (Person &quot;John&quot; 42) &quot;name&quot; = &quot;John&quot;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">--  Example: fieldValueAsString (Person &quot;John&quot; 42) &quot;age&quot; = &quot;42&quot;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="co">--  if the field is not present in the entity, an error is thrown.</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="ot">fieldValueAsString ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>fieldValueAsString x field <span class="ot">=</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  valueList <span class="op">!!</span> <span class="fu">index</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    fieldList <span class="ot">=</span> fieldNames x</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    valueList <span class="ot">=</span> fieldValues x</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">index</span> <span class="ot">=</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>      expectJust</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;Field &quot;</span> <span class="op">++</span> field <span class="op">++</span> <span class="st">&quot; is not present in type &quot;</span> <span class="op">++</span> typeName x)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        (elemIndex field fieldList)</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that take an entity as input parameter and returns a list of </span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="co">--   Strings representing the values of all fields of the entity.</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span class="co">--   Example: fieldValues (Person &quot;John&quot; 42) = [&quot;John&quot;, &quot;42&quot;]</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span class="ot">fieldValues ::</span> (<span class="dt">Data</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>fieldValues <span class="ot">=</span> gmapQ gshow</span></code></pre></div>
<h4 id="selecting-an-entity">Selecting an entity</h4>
<p>Creating a select query with <code>selectStmtFor</code> works slightly different than <code>insertStmtFor</code> and <code>updateStmtFor</code>. When creating a <code>SELECT</code> statement we don’t have an entity to inspect. Instead we need to know the type of the entity and the primary key value of the entity we want to select.
That’s why we need to pass the type information and the primary key value as parameters to the <code>selectStmtFor</code> function:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | This function takes a `TypeInfo` object and a primary key value as input parameters and returns a select statement for the entity.</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="ot">selectStmtFor ::</span> (<span class="dt">Show</span> <span class="fu">id</span>) <span class="ot">=&gt;</span> <span class="dt">TypeInfo</span> a <span class="ot">-&gt;</span> <span class="fu">id</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>selectStmtFor ti eid <span class="ot">=</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;SELECT &quot;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> intercalate <span class="st">&quot;, &quot;</span> (fieldNamesFromTypeInfo ti)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; FROM &quot;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> tiTypeName ti</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; WHERE &quot;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> idColumn ti</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; = &quot;</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="fu">show</span> eid</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;;&quot;</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns the (unqualified) type name of `a` from a `TypeInfo a` object.</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="ot">tiTypeName ::</span> <span class="dt">TypeInfo</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>tiTypeName <span class="ot">=</span> dataTypeName <span class="op">.</span> constrType <span class="op">.</span> typeConstructor    </span></code></pre></div>
<p>Apart from <code>tiTypeName</code> we have already seen all the other ingredients of the <code>selectStmtFor</code> function.</p>
<h3 id="the-retrievebyid-function">The <code>retrieveById</code> function</h3>
<p>The <code>retrieveById</code> function is the counterpart of the <code>persist</code> function. It takes a connection and a primary key value as input parameters and returns the entity with the given primary key value. If no unique entity with the given primary key value exists, an error is thrown.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that retrieves an entity from a database.</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   The function takes an HDBC connection and an entity id as parameters.</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   It returns the entity of type `a` with the given id.</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">--   An error is thrown if no such entity exists or if there are more than one entity with the given id.</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="ot">retrieveById ::</span> <span class="kw">forall</span> a conn <span class="fu">id</span><span class="op">.</span> (<span class="dt">Data</span> a, <span class="dt">IConnection</span> conn, <span class="dt">Show</span> <span class="fu">id</span>) <span class="ot">=&gt;</span> conn <span class="ot">-&gt;</span> <span class="fu">id</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>retrieveById conn eid <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ti <span class="ot">=</span> typeInfoFromContext </span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>      stmt <span class="ot">=</span> selectStmtFor ti eid</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="st">&quot;Retrieve &quot;</span> <span class="op">++</span> tiTypeName ti <span class="op">++</span> <span class="st">&quot; with id &quot;</span> <span class="op">++</span> <span class="fu">show</span> eid</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  resultRowsSqlValues <span class="ot">&lt;-</span> quickQuery conn stmt []</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> resultRowsSqlValues <span class="kw">of</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;No &quot;</span> <span class="op">++</span> <span class="fu">show</span> (typeConstructor ti) <span class="op">++</span> <span class="st">&quot; found for id &quot;</span> <span class="op">++</span> <span class="fu">show</span> eid</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    [singleRowSqlValues] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> <span class="op">$</span> </span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>        expectJust </span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>          (<span class="st">&quot;No &quot;</span> <span class="op">++</span> <span class="fu">show</span> (typeConstructor ti) <span class="op">++</span> <span class="st">&quot; found for id &quot;</span> <span class="op">++</span> <span class="fu">show</span> eid) </span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>          (buildFromRecord ti<span class="ot"> singleRowSqlValues ::</span> <span class="dt">Maybe</span> a)</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;More than one entity found for id &quot;</span> <span class="op">++</span> <span class="fu">show</span> eid</span></code></pre></div>
<p>We have already seen the <code>selectStmtFor</code> function in the previous section. But we have two other quite elaborated ingredients to make the <code>retrieveById</code> function work:</p>
<ul>
<li>The <code>typeInfoFromContext</code> function is a helper function that returns the <code>TypeInfo</code> instance for the entity type <code>a</code>:</li>
<li>The <code>buildFromRecord</code> function takes a <code>TypeInfo</code> instance and a list of <code>SqlValue</code> objects and returns the entity of type <code>a</code> if the list of <code>SqlValue</code> objects can be converted to the entity type <code>a</code>. If the conversion fails, <code>Nothing</code> is returned.</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | This function creates a TypeInfo object from the context of a function call.</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   The Phantom Type parameter `a` is used to convince the compiler that the `TypeInfo a` object really describes type `a`.  </span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   See also https://stackoverflow.com/questions/75171829/how-to-obtain-a-data-data-constr-etc-from-a-type-representation</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="ot">typeInfoFromContext ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> <span class="dt">TypeInfo</span> a</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>typeInfoFromContext <span class="ot">=</span> </span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dt <span class="ot">=</span> dataTypeOf (<span class="fu">undefined</span><span class="ot"> ::</span> a)   <span class="co">-- This is the trick to get the type from the context. </span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>      constr <span class="ot">=</span> <span class="kw">case</span> dataTypeConstrs dt <span class="kw">of</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        [cnstr] <span class="ot">-&gt;</span> cnstr</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        _       <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;typeInfoFromContext: Only types with one constructor are supported&quot;</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>      evidence <span class="ot">=</span> fromConstr<span class="ot"> constr ::</span> a  <span class="co">-- this is evidence for the compiler that we have created a value of type `a`</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> typeInfo evidence</span></code></pre></div>
<p>This is quite dense, so let’s take it step by step:</p>
<p>First we use <code>dataTypeOf :: a -&gt; DataType</code> to get the <code>DataType</code> object for the type <code>a</code>.
As we don’t have a value of type <code>a</code> at hand, we have to take it from thin air. So we use an <code>undefined :: a</code> as parameter.
This looks a bit awkward, but seems to be the official way to do it.</p>
<p>Then we use <code>dataTypeConstrs</code> to get a list of <code>DataConstr</code> objects for the type <code>a</code>.
If the list contains exactly one constructor, we use it to create a sample value of type <code>a</code> with <code>fromConstr</code>.
Otherwise we throw an error.</p>
<p>Finally, this sample value <code>evidence</code> is used to create a <code>TypeInfo a</code> object for the type <code>a</code>.
It is important to understand that <code>evidence</code> being of type <code>a</code> forms a proof that the <code>TypeInfo a</code>
object really describes the type <code>a</code> from the context of the function.</p>
<p>Cudos to <a href="https://stackoverflow.com/questions/75171829/how-to-obtain-a-data-data-constr-etc-from-a-type-representation">the brilliant people on stackoverflow</a>
for the explanation of how to get the <code>DataType</code> object from thin air.</p>
<p>The <code>buildFromRecord</code> function is even a bit more complex.
It takes a <code>TypeInfo a</code> object and a list of <code>SqlValue</code> objects and tries to construct an entity of type <code>a</code>
from the list of <code>SqlValue</code> objects. If the construction fails, <code>Nothing</code> is returned:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | This function takes a `TypeInfo a`and a List of HDBC `SqlValue`s and returns a `Maybe a`.</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co">--  If the construction of an entity fails, Nothing is returned, otherwise Just a.</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ot">buildFromRecord ::</span> (<span class="dt">Data</span> a) <span class="ot">=&gt;</span> <span class="dt">TypeInfo</span> a <span class="ot">-&gt;</span> [<span class="dt">SqlValue</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>buildFromRecord ti record <span class="ot">=</span> applyConstr ctor dynamicsArgs</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    ctor <span class="ot">=</span> typeConstructor ti</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    types <span class="ot">=</span> <span class="fu">map</span> fieldType (typeFields ti)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    dynamicsArgs <span class="ot">=</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>      expectJust</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;buildFromRecord: error in converting record &quot;</span> <span class="op">++</span> <span class="fu">show</span> record)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        (zipWithM convert types record)</span></code></pre></div>
<p>Before we can apply the <code>applyConstr</code> function to instantiate an <code>a</code> value, we have to do some preparation work.
The <code>[SqlValue]</code> list contains the values of the fields of the entity as they are coming from the database.
In order to use these values to instantiate an <code>a</code> value, we have to convert them to the types of the fields of the entity.
In order to use them as list elements we wrap them in <code>Dynamic</code> objects.
See also this Haskell Wiki entry on <a href="https://wiki.haskell.org/Heterogenous_collections#A_Universal_type">heterogenous collections with <code>Dynamic</code></a></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | convert a SqlValue into a Dynamic value that is backed by a value of the type represented by the SomeTypeRep parameter.</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co">--  If conversion fails, return Nothing.</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">--  conversion to Dynamic is required to allow the use of fromDynamic in applyConstr</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">--  see also https://stackoverflow.com/questions/46992740/how-to-specify-type-of-value-via-typerep</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="ot">convert ::</span> <span class="dt">SomeTypeRep</span> <span class="ot">-&gt;</span> <span class="dt">SqlValue</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Dynamic</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>convert (<span class="dt">SomeTypeRep</span> rep) val</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Int</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Int</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Double</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Double</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">String</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">String</span>)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Char</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Char</span>)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">B.ByteString</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">B.ByteString</span>)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Word32</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Word32</span>)</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Word64</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Word64</span>)</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Int32</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Int32</span>)</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Int64</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Int64</span>)</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Integer</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Integer</span>)</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Bool</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Bool</span>)</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">UTCTime</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">UTCTime</span>)</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">POSIXTime</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">POSIXTime</span>)</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">LocalTime</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">LocalTime</span>)</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">ZonedTime</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">ZonedTime</span>)</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">TimeOfDay</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">TimeOfDay</span>)</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Day</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Day</span>)</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">NominalDiffTime</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">NominalDiffTime</span>)</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Ratio</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Ratio</span> <span class="dt">Integer</span>)</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">TL.Text</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">TL.Text</span>)</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">TS.Text</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">TS.Text</span>)</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>The <code>convert</code> function takes a <code>SomeTypeRep</code>, representing the type of a given entity field, and a <code>SqlValue</code> object and tries to convert the <code>SqlValue</code> to the type represented by <code>SomeTypeRep</code>. If the conversion fails, <code>Nothing</code> is returned. This explicit conversion is needed keep the compiler happy.
As you can see the list of supported types already covers most of the types supported by HDBC.</p>
<p>Now we are ready to use the <code>applyConstr</code> function to instantiate an <code>a</code> value. The <code>applyConstr</code> function takes a <code>Constr</code> object and a list of <code>Dynamic</code> objects and tries to construct an entity of type <code>a</code> fromthe list of <code>Dynamic</code> objects. If the construction fails, <code>Nothing</code> is returned.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | This function takes a `Constr` and a list of `Dynamic` values and returns a `Maybe a`.</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   If an `a`entity could be constructed, Just a is returned, otherwise Nothing.</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   See also https://stackoverflow.com/questions/47606189/fromconstrb-or-something-other-useful</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co">--   for Info on how to use fromConstrM</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="ot">applyConstr ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> <span class="dt">Constr</span> <span class="ot">-&gt;</span> [<span class="dt">Dynamic</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>applyConstr ctor args <span class="ot">=</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span><span class="ot"> nextField ::</span> <span class="kw">forall</span> d<span class="op">.</span> <span class="dt">Data</span> d <span class="ot">=&gt;</span> <span class="dt">StateT</span> [<span class="dt">Dynamic</span>] <span class="dt">Maybe</span> d</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>      nextField <span class="ot">=</span> <span class="dt">StateT</span> uncons <span class="op">&gt;&gt;=</span> lift <span class="op">.</span> fromDynamic</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="kw">case</span> runStateT (fromConstrM nextField ctor) args <span class="kw">of</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> (x, []) <span class="ot">-&gt;</span> <span class="dt">Just</span> x</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>        _            <span class="ot">-&gt;</span> <span class="dt">Nothing</span> <span class="co">-- runtime type error or too few / too many arguments</span></span></code></pre></div>
<h3 id="the-retrieveall-function">The <code>retrieveAll</code> function</h3>
<p>This function is used to retrieve all entities of a given type from the database. It takes an HDBC connection as parameter and returns a list of entities of type <code>a</code>. The type <code>a</code> is determined by the context of the function call.</p>
<p>As you can see, thisd function reuses most of the ingredients from <code>retrieveById</code> but just uses a simpler SQL statement to retrieve all entities of a given type:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | This function retrieves all entities of type `a` from a database.</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co">--  The function takes an HDBC connection as parameter.</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co">--  The type `a` is determined by the context of the function call.</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="ot">retrieveAll ::</span> <span class="kw">forall</span> a conn<span class="op">.</span> (<span class="dt">Data</span> a, <span class="dt">IConnection</span> conn) <span class="ot">=&gt;</span> conn <span class="ot">-&gt;</span> <span class="dt">IO</span> [a]</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>retrieveAll conn <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ti <span class="ot">=</span> typeInfoFromContext</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>      stmt <span class="ot">=</span> selectAllStmtFor ti</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="st">&quot;Retrieve all &quot;</span> <span class="op">++</span> tiTypeName ti <span class="op">++</span> <span class="st">&quot;s&quot;</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  resultRowsSqlValues <span class="ot">&lt;-</span> quickQuery conn stmt []</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">map</span> (expectJust <span class="st">&quot;No entity found&quot;</span>) (<span class="fu">map</span> (buildFromRecord ti)<span class="ot"> resultRowsSqlValues ::</span> [<span class="dt">Maybe</span> a])</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="ot">selectAllStmtFor ::</span> <span class="dt">TypeInfo</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>selectAllStmtFor ti <span class="ot">=</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;SELECT &quot;</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> intercalate <span class="st">&quot;, &quot;</span> (fieldNamesFromTypeInfo ti)</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; FROM &quot;</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> tiTypeName ti</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;;&quot;</span></span></code></pre></div>
<h3 id="the-delete-function">The <code>delete</code> function</h3>
<p>This function is used to delete an entity from the database. It takes an HDBC connection and an entity of type <code>a</code> as parameters. It also does not bring anything new to the table. It just uses the <code>deleteStmtFor</code> function to generate the SQL statement to delete the entity from the database:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">delete ::</span> (<span class="dt">IConnection</span> conn, <span class="dt">Data</span> a) <span class="ot">=&gt;</span> conn <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>delete conn entity <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="st">&quot;Deleting &quot;</span> <span class="op">++</span> typeName entity <span class="op">++</span> <span class="st">&quot; with id &quot;</span> <span class="op">++</span> entityId entity</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  runRaw conn (deleteStmtFor entity)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  commit conn</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="ot">deleteStmtFor ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>deleteStmtFor x <span class="ot">=</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;DELETE FROM &quot;</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="fu">show</span> (typeName x)</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; WHERE &quot;</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> idColumn ti</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; = &quot;</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> fieldValueAsString x (idColumn ti)</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;;&quot;</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    ti <span class="ot">=</span> typeInfo x</span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>We have learnt ho use <code>Data</code> based Generics to implement a simple persistence library. The user will not have to write any boilerplate code. The library will generate the SQL statements and the code to convert back and forth between the database records and Haskell entities.</p>
<p>The library is by no means complete. Right now it’s just a proof of concept.
But it shows that it is possible to use Generics to eliminate a lot of handwritten code in the implementation of a persistence library.</p>
<p>I’m explicitely asking for your feedback here:</p>
<ul>
<li>Do you regard such a persistence API as useful?</li>
<li>Do you have any suggestions for improvements?</li>
<li>Which feature would you like to see most urgently?</li>
<li>Do you think it makes sense to extend this proof of concept to a full fledged solution,
or are there already enough libraries out there that do the same?</li>
</ul>
]]></description>
    <pubDate>Sat, 21 Jan 2023 00:00:00 UT</pubDate>
    <guid>https://thma.github.io//posts/2023-01-21-a-haskell-persistence-layer-using-generics-and-reflection.html</guid>
    <dc:creator>Thomas Mahler</dc:creator>
</item>
<item>
    <title>Dependency Validation of a Haskell Application</title>
    <link>https://thma.github.io//posts/2022-08-07-dependency-validation-of-haskell-applications.html</link>
    <description><![CDATA[<div class="info">
    <em>Posted on August  7, 2022
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<p><a href="https://github.com/thma/PolysemyCleanArchitecture/actions"><img src="https://github.com/thma/PolysemyCleanArchitecture/workflows/Haskell%20CI/badge.svg" alt="Actions Status" /></a>
<a href="https://github.com/thma/PolysemyCleanArchitecture"><img src="https://thma.github.io/img/forkme.png" height="20" ></a></p>
<h2 id="abstract">Abstract</h2>
<p>In this post I’m presenting a DependencyChecker to validate module dependencies in Haskell applications that can easily be integrated in CI/CD pipelines.
The solution is based on the Graphmod dependency visualization tool.</p>
<h2 id="introduction">Introduction</h2>
<p>Welcome to yet another sequel of <a href="https://thma.github.io/posts/2020-05-29-polysemy-clean-architecture.html">Clean Architecture with Haskell and Polysemy</a>.</p>
<p>In my last to posts (<a href="https://thma.github.io/posts/2022-07-04-polysemy-and-warp.html">integration of Warp and Hal</a> and <a href="https://thma.github.io/posts/2022-07-17-configuration-of-a-polysemy-app.html">configuration of a polysemy app</a>) I was adding new features to my code base without caring much about one of the core rules of CleanArchitecture:</p>
<blockquote>
<p>The overriding rule that makes this architecture work is <strong>The Dependency Rule</strong>.
This rule says that source code dependencies can only point inwards.
Nothing in an inner circle can know anything at all about something in an outer circle.
In particular, the name of something declared in an outer circle must not be mentioned by the code in the an inner circle.
That includes, functions, classes. variables, or any other named software entity.</p>
<p><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Uncle Bob</a></p>
</blockquote>
<p>At one point for example I noticed that a module in the <code>InterfaceAdapters</code> package referenced code in the <code>ExternalInterfaces</code> package further out.</p>
<p>This mishap was easy to fix by moving the module to the <code>ExternalInterfaces</code> package , but I thought about ways to visualize module dependencies and to automatically verify that all dependencies comply to the <strong>dependency rule</strong>.</p>
<p>In this post I’ll share my findings.</p>
<h2 id="visualizing-module-dependencies-with-graphmod">Visualizing Module dependencies with graphmod</h2>
<p>Whenever I think I had a brilliant idea, the Internet keeps telling me that someone else already had the same idea years ago…</p>
<p>So before starting to write my own <em>Module Dependency Visualizer</em> tool, I asked the Internet if others already had the same idea.
And – not so surprisingly – I found <a href="https://github.com/yav/graphmod">Graphmod</a> by Iavor S. Diatchki. It analyses cabal or stack based projects and outputs <a href="https://graphviz.org/">GraphViz</a> DOT models.</p>
<p>After installing it with</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">cabal</span> install graphmod</span></code></pre></div>
<p>The following command generates a detailed view on the dependencies in the PolySemyCleanArchitecture project:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">graphmod</span> <span class="kw">|</span> <span class="ex">dot</span> <span class="at">-Tpdf</span> <span class="op">&gt;</span> dependencies.pdf</span></code></pre></div>
<p>Here is the output:</p>
<p><img src="../img/dependencies.png" /></p>
<p>As required by the CleanArchitecture model all dependencies are directed inwards. No dependencies are going from inner layers to more outward layers.</p>
<p>Graphmod also provides additional flags to reduce clutter by pruning, to visualize the dependencies without package clustering, etc.<br />
You’ll find a few examples in <a href="https://github.com/yav/graphmod/wiki">the graphmod wiki</a>.</p>
<h2 id="automating-cleanarchitecture-dependency-validation">Automating CleanArchitecture dependency validation</h2>
<p>Visually inspecting a code base in this way is great. But it still involves manual effort if we intend to re-evaluate this image after each code change.</p>
<p>Wouldn’t it be much more adequate to provide a fully automated dependency check to be include in each CI/CD run?</p>
<p>So in this section we are going to build such a tool.</p>
<h3 id="how-to-define-cleanarchitecture-compliance">How to define CleanArchitecture compliance?</h3>
<p>According to the dependency rule only references from outer to inner layers are permitted.</p>
<p>Given the four packages of our PolysemyCleanArchitecture project:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | the list of source packages in descending order from outermost to innermost package in our CleanArchitecture project</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ot">cleanArchitecturePackages ::</span> [<span class="dt">Package</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>cleanArchitecturePackages <span class="ot">=</span> [<span class="st">&quot;ExternalInterfaces&quot;</span>, <span class="st">&quot;InterfaceAdapters&quot;</span>, <span class="st">&quot;UseCases&quot;</span>, <span class="st">&quot;Domain&quot;</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- | this type represents the package structure of a module e.g. Data.Time.Calendar resides in package Date.Time</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Package</span> <span class="ot">=</span> <span class="dt">String</span></span></code></pre></div>
<p>all permitted dependency pairs <code>(fromModule, toModule)</code> can be computed with:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | for a given list of packages this function produces the set of all allowed dependency pairs between packages.</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   Allowed dependencies according to CleanArchitecture:</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   1. imports within the same package</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">--   2. imports from outer layers to inner layers</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="ot">cleanArchitectureCompliantDeps ::</span> [<span class="dt">Package</span>] <span class="ot">-&gt;</span> [(<span class="dt">Package</span>, <span class="dt">Package</span>)]</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>cleanArchitectureCompliantDeps [] <span class="ot">=</span> []</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>cleanArchitectureCompliantDeps lst<span class="op">@</span>(p <span class="op">:</span> ps) <span class="ot">=</span> <span class="fu">zip</span> (<span class="fu">repeat</span> p) lst <span class="op">++</span> cleanArchitectureCompliantDeps ps</span></code></pre></div>
<p><code>cleanArchitectureCompliantDeps cleanArchitecturePackages</code> thus yields:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>[(<span class="st">&quot;ExternalInterfaces&quot;</span>,<span class="st">&quot;ExternalInterfaces&quot;</span>),</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a> (<span class="st">&quot;ExternalInterfaces&quot;</span>,<span class="st">&quot;InterfaceAdapters&quot;</span>),</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a> (<span class="st">&quot;ExternalInterfaces&quot;</span>,<span class="st">&quot;UseCases&quot;</span>),</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a> (<span class="st">&quot;ExternalInterfaces&quot;</span>,<span class="st">&quot;Domain&quot;</span>),</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a> (<span class="st">&quot;InterfaceAdapters&quot;</span>,<span class="st">&quot;InterfaceAdapters&quot;</span>),</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a> (<span class="st">&quot;InterfaceAdapters&quot;</span>,<span class="st">&quot;UseCases&quot;</span>),</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a> (<span class="st">&quot;InterfaceAdapters&quot;</span>,<span class="st">&quot;Domain&quot;</span>),</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a> (<span class="st">&quot;UseCases&quot;</span>,<span class="st">&quot;UseCases&quot;</span>),</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a> (<span class="st">&quot;UseCases&quot;</span>,<span class="st">&quot;Domain&quot;</span>),</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a> (<span class="st">&quot;Domain&quot;</span>,<span class="st">&quot;Domain&quot;</span>)]</span></code></pre></div>
<p>The overall idea of the dependency check is to verify for all Haskell modules in our “src” folder that all their import statements are either contained in this list or are imports of some external libraries.</p>
<h3 id="getting-a-list-of-all-import-declarations-of-all-.hs-files">Getting a list of all import declarations of all .hs files</h3>
<p>In this step I will reuse functions and types from Graphmod. Graphmod comes with a <code>Graphmod.Utils</code> module that provides a function <code>parseFile :: FilePath -&gt; IO (ModName,[Import])</code> which parses a file into a representation of its import declaration section. <code>ModName</code> and <code>Import</code> are defined as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Import</span>    <span class="ot">=</span> <span class="dt">Import</span> {<span class="ot"> impMod ::</span> <span class="dt">ModName</span>,<span class="ot"> impType ::</span> <span class="dt">ImpType</span> } <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ImpType</span>   <span class="ot">=</span> <span class="dt">NormalImp</span> <span class="op">|</span> <span class="dt">SourceImp</span> <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>,<span class="dt">Ord</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Qualifier</span> <span class="ot">=</span> <span class="dt">Hierarchy</span> [<span class="dt">String</span>] <span class="op">|</span> <span class="dt">FromFile</span> [<span class="dt">String</span>] <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ModName</span>   <span class="ot">=</span> (<span class="dt">Qualifier</span>,<span class="dt">String</span>)</span></code></pre></div>
<p>Given this handy <code>parseFile</code> function we can collect all module import declaration under some folder <code>dir</code> with the following code:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | this type represents the section of import declaration at the beginning of a Haskell module</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ModuleImportDeclarations</span> <span class="ot">=</span> (<span class="dt">ModName</span>, [<span class="dt">Import</span>])</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- | scan all files under filepath &#39;dir&#39; and return a list of all their import declarations.</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="ot">allImportDeclarations ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">ModuleImportDeclarations</span>]</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>allImportDeclarations dir <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  files <span class="ot">&lt;-</span> allFiles dir</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM</span> parseFile files</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- | list all files in the given directory and recursively include all sub directories</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="ot">allFiles ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">FilePath</span>]</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>allFiles dir <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  files <span class="ot">&lt;-</span> listDirectory dir</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> qualifiedFiles <span class="ot">=</span> <span class="fu">map</span> (\f <span class="ot">-&gt;</span> dir <span class="op">++</span> <span class="st">&quot;/&quot;</span> <span class="op">++</span> f) files</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>  concatMapM</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    ( \f <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        isFile <span class="ot">&lt;-</span> doesDirectoryExist f</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> isFile</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>          <span class="kw">then</span> allFiles f</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> <span class="fu">return</span> [f]</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    qualifiedFiles</span></code></pre></div>
<h4 id="always-fix-things-upstream">Always fix things upstream</h4>
<p>As of version 1.4.4 Graphmod can not be included as a library dependency via Cabal or Stack. This will be fixed in 1.4.5. I have provided an additional <a href="https://github.com/yav/graphmod/pull/40">pull request</a> that will allow to use the <code>Graphmod.Utils</code> via a dependency declaration in your <code>package.yaml</code> or cabal file. As long as version 1.4.5 is not available on Hackage we’ll have to use the respective version directly from Github by adding the following stanza to <code>stack.yaml</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">extra-deps</span><span class="kw">:</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="fu">git</span><span class="kw">:</span><span class="at"> https://github.com/yav/graphmod.git</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">commit</span><span class="kw">:</span><span class="at"> 79cc6502b48e577632d57b3a9b479436b0739726</span></span></code></pre></div>
<h3 id="validating-the-module-import-declarations">Validating the module import declarations</h3>
<p>Now that we have all <code>ModuleImportDeclarations</code> collected in a list we must validate each of them.
We start with a function that validates the import declaration section of a single module as represented by a <code>ModuleImportDeclarations</code> instance. In order to validate this section we have to provide two more items:</p>
<ol type="1">
<li><p>a list <code>allPackages</code> containing all packages under consideration (in our case the <code>cleanArchitecturePackages</code> as defined above)</p></li>
<li><p>a list of all compliant dependency pairings between elements of the <code>allPackages</code> list, in our case the <code>cleanArchitectureCompliantDeps cleanArchitecturePackages</code> as defined above</p></li>
</ol>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | this function verifies a ModuleImportDeclarations instance</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   (that is all import declarations of a given Haskell module.)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   If all imports comply to the rules Right () is returned.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">--   If offending imports are found, they are returned via Left.</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="ot">verifyImportDecl ::</span> [<span class="dt">Package</span>] <span class="ot">-&gt;</span> [(<span class="dt">Package</span>, <span class="dt">Package</span>)] <span class="ot">-&gt;</span> <span class="dt">ModuleImportDeclarations</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ModuleImportDeclarations</span> ()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>verifyImportDecl allPackages compliantDependencies (packageFrom, imports) <span class="ot">=</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> offending <span class="ot">=</span> <span class="fu">filter</span> (<span class="fu">not</span> <span class="op">.</span> verify packageFrom) imports</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="kw">if</span> <span class="fu">null</span> offending</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> <span class="dt">Right</span> ()</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="dt">Left</span> (packageFrom, offending)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- | verify checks a single import declaration.</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">--   An import is compliant iff:</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">--   1. it refers to some external package which not member of the &#39;packages&#39; list or</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">--   2. the package dependency is a member of the compliant dependencies between elements of the &#39;packages&#39; list.</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="ot">    verify ::</span> <span class="dt">ModName</span> <span class="ot">-&gt;</span> <span class="dt">Import</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    verify pFrom imp <span class="ot">=</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>      importPackage imp <span class="ot">`notElem`</span> allPackages</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">||</span> (modulePackage pFrom, importPackage imp) <span class="ot">`elem`</span> compliantDependencies</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- | this function returns the Package information from an Import definition</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="ot">importPackage ::</span> <span class="dt">Import</span> <span class="ot">-&gt;</span> <span class="dt">Package</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>importPackage imp <span class="ot">=</span> modulePackage (impMod imp)</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="co">-- | this function returns the Package information from a ModName definition</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a><span class="ot">modulePackage ::</span> <span class="dt">ModName</span> <span class="ot">-&gt;</span> <span class="dt">Package</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>modulePackage (q, _m) <span class="ot">=</span> intercalate <span class="st">&quot;.&quot;</span> (qualifierNodes q)</span></code></pre></div>
<p>As a next step we define a function that maps the function <code>verifyImportDecl</code> over the complete list of all <code>ModuleImportDeclarations</code>. This results in a List of Eithers. I’m using <code>partitionEither</code> to transform the result into an
<code>Either [(ModName, [Import])] ()</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | verify the dependencies of a list of module import declarations. The results are collected into an &#39;Either [(ModName, [Import])] ()&#39; which will be easier to handle in subsequent steps.</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">verifyAllDependencies ::</span> [<span class="dt">Package</span>] <span class="ot">-&gt;</span> [(<span class="dt">Package</span>, <span class="dt">Package</span>)] <span class="ot">-&gt;</span> [<span class="dt">ModuleImportDeclarations</span>] <span class="ot">-&gt;</span> <span class="dt">Either</span> [(<span class="dt">ModName</span>, [<span class="dt">Import</span>])] ()</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>verifyAllDependencies allPackages compliantDependencies imports<span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> results <span class="ot">=</span> <span class="fu">map</span> (verifyImportDecl allPackages compliantDependencies) imports</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (errs, _compliant) <span class="ot">=</span> partitionEithers results</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> <span class="fu">null</span> errs</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="dt">Right</span> ()</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="dt">Left</span> errs</span></code></pre></div>
<p>We can use the generic <code>verifyAllDependencies</code> to create a specific <code>verifyCleanArchitectureDependencies</code> function which uses <code>cleanArchitecturePackages</code> and <code>cleanArchitectureCompliantDeps</code> to define the dependency rules for our CleanArchitecture project:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | verify a list of ModuleImportDeclarations to comply to the clean architecture dependency rules.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">verifyCleanArchitectureDependencies ::</span> [<span class="dt">ModuleImportDeclarations</span>] <span class="ot">-&gt;</span> <span class="dt">Either</span> [(<span class="dt">ModName</span>, [<span class="dt">Import</span>])] ()</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>verifyCleanArchitectureDependencies <span class="ot">=</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  verifyAllDependencies</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    cleanArchitecturePackages</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    (cleanArchitectureCompliantDeps cleanArchitecturePackages)</span></code></pre></div>
<h2 id="using-the-dependency-checker-in-test-cases">Using the dependency checker in test cases</h2>
<p>Using the dependency checker in test cases is quite straighforward.
First load all import declaractions than validate them:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.Hspec</span> ( hspec, describe, it, shouldBe, <span class="dt">Spec</span> )</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">DependencyChecker</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    ( <span class="dt">ModName</span>,</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">ImpType</span>(<span class="op">..</span>),</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Import</span>(<span class="op">..</span>),</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>      fromHierarchy,</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>      verifyCleanArchitectureDependencies,</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>      allImportDeclarations )</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> hspec spec</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="ot">spec ::</span> <span class="dt">Spec</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>spec <span class="ot">=</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  describe <span class="st">&quot;The Dependency Checker&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    it <span class="st">&quot;ensures that all modules comply to the outside-in rule&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>      allImports <span class="ot">&lt;-</span> allImportDeclarations <span class="st">&quot;src&quot;</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>      formatLeftAsErrMsg </span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>        (verifyCleanArchitectureDependencies allImports) <span class="ot">`shouldBe`</span> <span class="dt">Right</span> ()</span></code></pre></div>
<p>As you can see from executing the tests with <code>stack test</code>, the dependency checker does not find any issues in the codebase:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">CleanArchitecture</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="ex">The</span> Dependency Checker</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">ensures</span> that all modules comply to the outside-in rule</span></code></pre></div>
<p>But if we add an offending dependency to some of the modules, say adding</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">InterfaceAdapters.Config</span></span></code></pre></div>
<p>to <code>Domain.ReservationDomain</code> and to <code>UseCases.ReservationUseCase</code>, we’ll get a failure with the following message:</p>
<pre><code>Failures:

  test/CleanArchitectureSpec.hs:22:75: 
  1) CleanArchitecture, The Dependency Checker, makes sure all modules comply to the outside-in rule
       expected: Right ()
        but got: Left [
          &quot;Domain.ReservationDomain imports InterfaceAdapters.Config&quot;,
          &quot;UseCases.ReservationUseCase imports InterfaceAdapters.Config&quot;]
</code></pre>
<p>the rendering of the Error message is done by the helper function <code>formatLeftAsErrMsg</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Right () is returned unchanged, </span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   Left imports will be rendered as a human readable error message.</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ot">formatLeftAsErrMsg ::</span> <span class="dt">Either</span> [<span class="dt">ModuleImportDeclarations</span>] () <span class="ot">-&gt;</span> <span class="dt">Either</span> [<span class="dt">String</span>] ()</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>formatLeftAsErrMsg (<span class="dt">Right</span> ()) <span class="ot">=</span> <span class="dt">Right</span> ()</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>formatLeftAsErrMsg (<span class="dt">Left</span> imports) <span class="ot">=</span> <span class="dt">Left</span> (<span class="fu">map</span> toString imports)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    toString ::</span> <span class="dt">ModuleImportDeclarations</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    toString (modName, imports) <span class="ot">=</span> ppModule modName <span class="op">++</span> <span class="st">&quot; imports &quot;</span> <span class="op">++</span> intercalate <span class="st">&quot;, &quot;</span> (<span class="fu">map</span> (ppModule <span class="op">.</span> impMod) imports)</span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>Thanks to Graphmod rolling our own depency checker worked like a charm.</p>
<p>In this post I used my PolysemyCleanArchitecture project as an example. However the dependency checker is flexible enough to validate quite different dependency requirements as well.</p>
<p>For instance you could use it to limit the access to a database library to specific data-access modules in your codebase.</p>
<p>Adding such an automated dependency validation to a testsuite may help to maintain dependency constraints automatically with each execution of the CI/CD pipeline.</p>
]]></description>
    <pubDate>Sun, 07 Aug 2022 00:00:00 UT</pubDate>
    <guid>https://thma.github.io//posts/2022-08-07-dependency-validation-of-haskell-applications.html</guid>
    <dc:creator>Thomas Mahler</dc:creator>
</item>
<item>
    <title>Configuration of a Polysemy application</title>
    <link>https://thma.github.io//posts/2022-07-17-configuration-of-a-polysemy-app.html</link>
    <description><![CDATA[<div class="info">
    <em>Posted on July 17, 2022
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<p><a href="https://github.com/thma/PolysemyCleanArchitecture/actions"><img src="https://github.com/thma/PolysemyCleanArchitecture/workflows/Haskell%20CI/badge.svg" alt="Actions Status" /></a>
<a href="https://github.com/thma/PolysemyCleanArchitecture"><img src="https://thma.github.io/img/forkme.png" height="20" ></a></p>
<h2 id="introduction">Introduction</h2>
<p>This is yet another sequel to my <a href="https://thma.github.io/posts/2020-05-29-polysemy-clean-architecture.html">Clean Architecture with Haskell and Polysemy article</a>.</p>
<p>In my last blog post I demonstrated how the actual hosting of a WAI web app (e.g. with the Warp server or on AWS Lambda) can be defined as a Polysemy effect.
The idea was well received on <a href="https://www.reddit.com/r/haskell/">reddit/r/haskell</a> and also stirred some further discussions.
One question that came up: why did I explicitly load configuration before starting the Polysemy effect interpreter?
Wouldn’t it be much more in line with the overall idea of my <em>Polysemy Clean Architecture</em> to handle this loading also as an effect?</p>
<p>Here is my original code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  config <span class="ot">&lt;-</span> loadConfig       <span class="co">-- load config BEFORE starting the Polysemy effect interpreter</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  serveAppFromConfig config  <span class="co">-- create app from config and run it via AppServer effect</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span> runWarpAppServer       <span class="co">-- use Warp to run rest application</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span> runM</span></code></pre></div>
<p>I explained my reasons for this design but promised to look for a better solution.</p>
<p>In the following I’ll explain the new design that I came up with.</p>
<h2 id="the-ideas-behind-my-original-design">The ideas behind my original design</h2>
<p>The central reason for explicitely loading the configuration before starting the polysemy interpreter was that the configuration <code>config</code> is needed to select effect interpreter functions in the assembly of the WAI web app. To better understand this we’ll drill down the execution sequence starting from <code>runWarpAppServer</code> effect handler:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runWarpAppServer ::</span> (<span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r) <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">AppServer</span> <span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>runWarpAppServer <span class="ot">=</span> interpret <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- serving an application by constructing it from a config</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ServeAppFromConfig</span> config <span class="ot">-&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    embed <span class="op">$</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> app <span class="ot">=</span> createApp config</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> <span class="kw">do</span> </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;starting Warp on Port &quot;</span> <span class="op">++</span> <span class="fu">show</span> (port config)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        Warp.run (port config) app</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="ot">createApp ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>createApp config <span class="ot">=</span> serve reservationAPI (liftServer config)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="ot">liftServer ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">ServerT</span> <span class="dt">ReservationAPI</span> <span class="dt">Handler</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>liftServer config <span class="ot">=</span> hoistServer reservationAPI (interpretServer config) reservationServer</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    interpretServer ::</span> (<span class="dt">Show</span> k, <span class="dt">Read</span> k, <span class="dt">ToJSON</span> v, <span class="dt">FromJSON</span> v)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>                    <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> &#39;[<span class="dt">KVS</span> k v, <span class="dt">Input</span> <span class="dt">Config</span>, <span class="dt">Trace</span>, <span class="dt">Error</span> <span class="dt">ReservationError</span>, <span class="dt">Embed</span> <span class="dt">IO</span>] a <span class="ot">-&gt;</span> <span class="dt">Handler</span> a</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    interpretServer config sem  <span class="ot">=</span>  sem</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>      <span class="op">&amp;</span> runSelectedKvsBackend config</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>      <span class="op">&amp;</span> runInputConst config</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>      <span class="op">&amp;</span> runSelectedTrace config</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>      <span class="op">&amp;</span> runError <span class="op">@</span><span class="dt">ReservationError</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>      <span class="op">&amp;</span> runM</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>      <span class="op">&amp;</span> liftToHandler</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="ot">    liftToHandler ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">ReservationError</span> a) <span class="ot">-&gt;</span> <span class="dt">Handler</span> a</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    liftToHandler <span class="ot">=</span> <span class="dt">Handler</span> <span class="op">.</span> <span class="dt">ExceptT</span> <span class="op">.</span> <span class="fu">fmap</span> handleErrors</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="ot">    handleErrors ::</span> <span class="dt">Either</span> <span class="dt">ReservationError</span> b <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ServerError</span> b</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    handleErrors (<span class="dt">Left</span> (<span class="dt">ReservationNotPossible</span> msg)) <span class="ot">=</span> <span class="dt">Left</span> err412 { errBody <span class="ot">=</span> <span class="fu">pack</span> msg}</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    handleErrors (<span class="dt">Right</span> value) <span class="ot">=</span> <span class="dt">Right</span> value</span></code></pre></div>
<p>The interesting point here is the usage of the <code>Config</code> parameter <code>config</code> in <code>interpretServer</code>.
It is used to select concrete effect handler functions in <code>runSelectedKvsBackend conf</code> and <code>runSelectedTrace conf</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | global application configuration</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Config</span> <span class="ot">=</span> <span class="dt">Config</span> {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  port        ::</span> <span class="dt">Int</span>     <span class="co">-- ^ the port where the server is listening</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>,<span class="ot"> backend     ::</span> <span class="dt">Backend</span> <span class="co">-- ^ selects the persistence backend for the KV store</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>,<span class="ot"> dbPath      ::</span> <span class="dt">String</span>  <span class="co">-- ^ the path to the database</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>,<span class="ot"> verbose     ::</span> <span class="dt">Bool</span>    <span class="co">-- ^ True enables logging</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>} <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Read</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Backend</span> <span class="ot">=</span> <span class="dt">SQLite</span> <span class="op">|</span> <span class="dt">FileServer</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Read</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- | can select between SQLite or FileServer persistence backends.</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="ot">runSelectedKvsBackend ::</span> (<span class="dt">Member</span> (<span class="dt">Input</span> <span class="dt">Config</span>) r, <span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r, <span class="dt">Member</span> <span class="dt">Trace</span> r, <span class="dt">Show</span> k, <span class="dt">Read</span> k, <span class="dt">ToJSON</span> v, <span class="dt">FromJSON</span> v)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>                 <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">KVS</span> k v <span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>runSelectedKvsBackend config <span class="ot">=</span> <span class="kw">case</span> backend config <span class="kw">of</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SQLite</span>     <span class="ot">-&gt;</span> runKvsAsSQLite</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">FileServer</span> <span class="ot">-&gt;</span> runKvsAsFileServer</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- | if the config flag verbose is set to True, trace to Console, else ignore all trace messages</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="ot">runSelectedTrace ::</span> (<span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r) <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> (<span class="dt">Sem</span> (<span class="dt">Trace</span> <span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>runSelectedTrace config <span class="ot">=</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> verbose config</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> traceToStdout</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> ignoreTrace</span></code></pre></div>
<p>In addition to this <code>config</code> is also used by the <code>Input</code> effect handler <code>runInputConst conf</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Run an &#39;Input&#39; effect by always giving back the same value.</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">runInputConst ::</span> i <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">Input</span> i &#39;<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>runInputConst c <span class="ot">=</span> interpret <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Input</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> c</span></code></pre></div>
<p>This allows effect handlers like <code>runKvsAsSQLite</code> to use <code>config</code> as configuration. For example to obtain the database connection:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Polysemy</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Polysemy.Input</span>                 (<span class="dt">Input</span>, input)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Polysemy.Trace</span>                 (<span class="dt">Trace</span>, trace)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- | delete a value from db identified by key</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="ot">deleteAction ::</span> (<span class="dt">Member</span> (<span class="dt">Input</span> <span class="dt">Config</span>) r, <span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r, <span class="dt">Member</span> <span class="dt">Trace</span> r, <span class="dt">Show</span> k) <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>deleteAction key <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="st">&quot;deleteAction: &quot;</span> <span class="op">++</span> <span class="fu">show</span> key</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  conn <span class="ot">&lt;-</span> connectionFrom input</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  embed <span class="op">$</span> SQL.executeNamed conn <span class="st">&quot;DELETE FROM store WHERE key = :key&quot;</span> [<span class="st">&quot;:key&quot;</span> <span class="op">:=</span> <span class="fu">show</span> key]</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- | create a connection based on configuration data, make sure table &quot;store&quot; exists.</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="ot">connectionFrom ::</span> (<span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r, <span class="dt">Member</span> <span class="dt">Trace</span> r) <span class="ot">=&gt;</span> <span class="dt">Sem</span> r <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r <span class="dt">SQL.Connection</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>connectionFrom c <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>  config <span class="ot">&lt;-</span> c</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="st">&quot;open connection to: &quot;</span> <span class="op">++</span> dbPath config</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  embed (getConnection (dbPath config))</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="ot">      getConnection ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">SQL.Connection</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>      getConnection dbFile <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        conn <span class="ot">&lt;-</span> SQL.open dbFile</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        SQL.execute_ conn <span class="st">&quot;CREATE TABLE IF NOT EXISTS store (key TEXT PRIMARY KEY, value TEXT)&quot;</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> conn</span></code></pre></div>
<p>My reasoning was as follows: As I needed <code>config</code> as an explicit parameter to <code>serveAppFromConfig</code> in the <code>main</code> glue code and <code>loadConfig</code>being of type <code>IO Config</code>, I thought I had to explicitely execute it in the <code>IO</code> Monad and then handing it into the Polysemy effect chain:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  config <span class="ot">&lt;-</span> loadConfig       <span class="co">-- load config</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  serveAppFromConfig config  <span class="co">-- create app from config and run it via AppServer effect</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span> runWarpAppServer       <span class="co">-- use Warp to run rest application</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span> runM</span></code></pre></div>
<p>But it turned out that I had just not thought things through deep enough!</p>
<h2 id="chaining-of-config-loading-and-application-execution-as-effects">Chaining of Config loading and application execution as effects</h2>
<p>If we take a step back and look at the code in the <code>UseCases</code> package we’ll see that we already have shown how to combine different effects into a sequence within the Polysemy <code>Sem</code> Monad.
Take for example the following use case implementation:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">cancel ::</span> (<span class="dt">Member</span> <span class="dt">Persistence</span> r, <span class="dt">Member</span> <span class="dt">Trace</span> r)  <span class="ot">=&gt;</span> <span class="dt">Dom.Reservation</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>cancel res<span class="op">@</span>(<span class="dt">Dom.Reservation</span> date _ _ _) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="st">&quot;deleting reservation &quot;</span> <span class="op">++</span> <span class="fu">show</span> res</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  reservations <span class="ot">&lt;-</span> fetch date</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="st">&quot;before: &quot;</span> <span class="op">++</span> <span class="fu">show</span> reservations</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> after <span class="ot">=</span> Dom.cancelReservation res reservations</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="st">&quot;after: &quot;</span> <span class="op">++</span> <span class="fu">show</span> after</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  insertKvs date after</span></code></pre></div>
<p>So instead of glueing stuff together in <code>main :: IO ()</code>, wouldn’t it be much more in line with our overall intention to formulate the sequencing of configuration loading and hosting the WAI application as a sequence of Polysemy effects? For example:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | load configuration via ConfigProvider effect, then contruct and run app via AppServer effect</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">configureAndServeApp ::</span>  (<span class="dt">Member</span> <span class="dt">ConfigProvider</span> r, <span class="dt">Member</span> <span class="dt">AppServer</span> r)  <span class="ot">=&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>configureAndServeApp <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  config <span class="ot">&lt;-</span> getConfig</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  serveAppFromConfig config</span></code></pre></div>
<p>In this function we use two effects <code>ConfigProvider</code> and <code>Appserver</code>. I already described the <code>AppServer</code> effect in <a href="https://thma.github.io/posts/2022-07-04-polysemy-and-warp.html">my previous blog post</a>. So we only have to consider the <code>ConfigProvider</code> effect here.</p>
<h2 id="defining-a-configprovider-effect">Defining a ConfigProvider Effect</h2>
<p>First we define the ConfigProvider Effect. It provides an effect function <code>getConfig :: Member ConfigProvider r =&gt; Sem r Config</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">ExternalInterfaces.ConfigProvider</span> <span class="kw">where</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">InterfaceAdapters.Config</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Polysemy</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- | The ConfigProvider effect can be used to provide and application with a Config instance.</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ConfigProvider</span> m a <span class="kw">where</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">GetConfig</span><span class="ot"> ::</span> <span class="dt">ConfigProvider</span> m <span class="dt">Config</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- makeSem uses TemplateHaskell to generate effect functions (or smart Constructors) from the GADT definition:</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- getConfig :: Member ConfigProvider r =&gt; Sem r Config</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>makeSem &#39;<span class="dt">&#39;ConfigProvider</span></span></code></pre></div>
<h2 id="implementing-the-configprovider-effect">Implementing the ConfigProvider effect</h2>
<p>Next we define an implementation of the <code>ConfigProvider</code> effect by defining an effect handler function
that loads a <code>Config</code> instance from a file:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">ExternalInterfaces.FileConfigProvider</span> <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">InterfaceAdapters.Config</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">ExternalInterfaces.ConfigProvider</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Polysemy</span> (<span class="dt">Embed</span>, <span class="dt">Member</span>, <span class="dt">Sem</span>, embed, interpret)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- | provides a Config object from a local file path</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="ot">runFileConfigProvider ::</span> (<span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r) <span class="ot">=&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">ConfigProvider</span> <span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>runFileConfigProvider path <span class="ot">=</span> interpret <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">GetConfig</span> <span class="ot">-&gt;</span> embed <span class="op">$</span> loadConfig path</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- | load application config from file &quot;application.config&quot;</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="ot">loadConfig ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Config</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>loadConfig path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>  input <span class="ot">&lt;-</span> <span class="fu">readFile</span> path</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> <span class="fu">read</span> input</span></code></pre></div>
<h2 id="the-new-and-shining-main-function">The new and shining main function</h2>
<p>Now we have all the ingredients ready to clean up the glue code in <code>main :: IO ()</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  configureAndServeApp</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span> runFileConfigProvider <span class="st">&quot;application.config&quot;</span>  <span class="co">-- provide Config from a file</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span> runWarpAppServer                            <span class="co">-- use Warp to run rest application</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span> runM</span></code></pre></div>
<p>The complete control of the application is now exclusively managed by the Polysemy effect library.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I’m excited about how the comments on my last blog post have helped me develop the
Polysemy Clean Architecture idea into a much improved design.</p>
<p>So I’m sure that this post will trigger some more discussions and will help to improve remaining grey spots in the
overall concept.</p>
]]></description>
    <pubDate>Sun, 17 Jul 2022 00:00:00 UT</pubDate>
    <guid>https://thma.github.io//posts/2022-07-17-configuration-of-a-polysemy-app.html</guid>
    <dc:creator>Thomas Mahler</dc:creator>
</item>
<item>
    <title>Warp as an effect in Polysemy</title>
    <link>https://thma.github.io//posts/2022-07-04-polysemy-and-warp.html</link>
    <description><![CDATA[<div class="info">
    <em>Posted on July  4, 2022
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<p><a href="https://github.com/thma/PolysemyCleanArchitecture/actions"><img src="https://github.com/thma/PolysemyCleanArchitecture/workflows/Haskell%20CI/badge.svg" alt="Actions Status" /></a>
<a href="https://github.com/thma/PolysemyCleanArchitecture"><img src="https://thma.github.io/img/forkme.png" height="20" ></a></p>
<h2 id="introduction">Introduction</h2>
<p>Two years ago I wrote <a href="https://thma.github.io/posts/2020-05-29-polysemy-clean-architecture.html">Implementing Clean Architecture with Haskell and Polysemy</a> where I demonstrated how core elements of Clean Architecture can be implemented with Polysemy in quite an elegant way.</p>
<p>A few months ago an interesting question was raised in the <a href="https://github.com/thma/PolysemyCleanArchitecture/issues/2">issues section of the respective GitHub project</a>:</p>
<blockquote>
<p>I’m wondering, if we want to change the server to serverless, is it easy to do that?
If we treat the server as an effect, can we just change the [polysemy effect] interpreter?</p>
</blockquote>
<p>This question points to one of the grey spots of my original design: The whole polysemy effect stack is executed as part of the <code>createApp</code> function which provides a <code>Network.Wai.Application</code> which is then executed by <code>Warp.run</code>.</p>
<p>Wouldn’t it be much more elegant to also define the server execution as an effect? This would make the overall design more homogenous by giving the final control to the Polysemy effect interpreter.</p>
<p>In this post I’m going to present a design that provides a solution for this.</p>
<h2 id="the-old-way">The ‘old’ way</h2>
<p>In order to better understand the issue lets have a brieve look at the original design.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  config <span class="ot">&lt;-</span> loadConfig           <span class="co">-- load configuration (e.g. from file)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> p <span class="ot">=</span> port config            <span class="co">-- obtain http port from config</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  Warp.run p (createApp config)  <span class="co">-- create Application based on config and run it</span></span></code></pre></div>
<p>As we can see from the <code>main</code> function our whole app is just an ordinary <code>Network.Wai.Application</code> which is executed by <code>Warp.run</code>.</p>
<p>So the final control of this application is managed by warp. We don’t see anything of Polysemy here. Only if we dig deeper we’ll find that the Polysemy effect stack is interpreted under the hood of the <code>Application</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">createApp ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>createApp config <span class="ot">=</span> serve reservationAPI (liftServer config)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ot">liftServer ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">ServerT</span> <span class="dt">ReservationAPI</span> <span class="dt">Handler</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>liftServer config <span class="ot">=</span> hoistServer reservationAPI (interpretServer config) reservationServer</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    interpretServer ::</span> (<span class="dt">Show</span> k, <span class="dt">Read</span> k, <span class="dt">ToJSON</span> v, <span class="dt">FromJSON</span> v)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                    <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> &#39;[<span class="dt">KVS</span> k v, <span class="dt">Input</span> <span class="dt">Config</span>, <span class="dt">Trace</span>, <span class="dt">Error</span> <span class="dt">ReservationError</span>, <span class="dt">Embed</span> <span class="dt">IO</span>] a <span class="ot">-&gt;</span> <span class="dt">Handler</span> a</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    interpretServer conf sem  <span class="ot">=</span>  sem</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;</span> runSelectedKvsBackend conf</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;</span> runInputConst conf</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;</span> runSelectedTrace conf</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;</span> runError <span class="op">@</span><span class="dt">ReservationError</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;</span> runM</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;</span> liftToHandler</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="ot">    liftToHandler ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">ReservationError</span> a) <span class="ot">-&gt;</span> <span class="dt">Handler</span> a</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    liftToHandler <span class="ot">=</span> <span class="dt">Handler</span> <span class="op">.</span> <span class="dt">ExceptT</span> <span class="op">.</span> <span class="fu">fmap</span> handleErrors</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="ot">    handleErrors ::</span> <span class="dt">Either</span> <span class="dt">ReservationError</span> b <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ServerError</span> b</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    handleErrors (<span class="dt">Left</span> (<span class="dt">ReservationNotPossible</span> msg)) <span class="ot">=</span> <span class="dt">Left</span> err412 { errBody <span class="ot">=</span> <span class="fu">pack</span> msg}</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    handleErrors (<span class="dt">Right</span> value) <span class="ot">=</span> <span class="dt">Right</span> value</span></code></pre></div>
<p>This design works perfectly fine and also follows the common practise to exploit the Servant <a href="https://hackage.haskell.org/package/servant-server-0.19.1/docs/Servant-Server.html#v:hoistServer"><code>hoistServer</code></a> mechanism.</p>
<p>The only complaint is that the Polysemy effect interpreter is not executed as the outermost piece of code. Accordingly we have to <em>deploy our application into warp</em> rather than having Polysemy in control and <em>executing warp as an effect</em>.</p>
<h2 id="the-new-solution">The new solution</h2>
<p>Ok let’s take the challenge and try to fix this ‘bug’!</p>
<p>My overall approach goes like this:</p>
<ol type="1">
<li><p>Define a new <code>ExternalInterfaces.AppServer</code> effect. This will allow to abstractly define
usage of an application server as a Polysemy effect.</p></li>
<li><p>Provide a Warp based implementation <code>ExternalInterfaces.WarpAppServer</code>.
This will interprete the <code>AppServer</code> effect by running <a href="http://www.aosabook.org/en/posa/warp.html">Warp</a>.</p></li>
<li><p>write a main function that drives the whole Polysemy effect stack, including the Warp server.</p></li>
</ol>
<h3 id="the-appserver-effect">The AppServer effect</h3>
<p>First we define an abstract <code>AppServer</code> effect which captures the notion of executing a web application inside an http based server.
We’ll support two constructors <code>ServeApp</code> which is more generic as it is modelled after the function signature of <code>Warp.run</code>.
The second constructor <code>ServeAppFromConfig</code> is matching the design of my original polysemy app where different elements of the application
can be configured by a central <code>Config</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">ExternalInterfaces.AppServer</span> <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">InterfaceAdapters.Config</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Network.Wai</span>              (<span class="dt">Application</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Polysemy</span>                 (makeSem)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AppServer</span> m a <span class="kw">where</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ServeApp</span><span class="ot">           ::</span> <span class="dt">Application</span> <span class="ot">-&gt;</span> <span class="dt">AppServer</span> m () <span class="co">-- ^ serve a given application on a port</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ServeAppFromConfig</span><span class="ot"> ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">AppServer</span> m ()      <span class="co">-- ^ construct an application from a configuration and serve it</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- using TemplateHaskell to generate serveApp and serveAppFromConfig effect functions</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>makeSem &#39;<span class="dt">&#39;AppServer</span></span></code></pre></div>
<h3 id="the-warp-based-implementation-of-the-effect">The Warp based implementation of the effect</h3>
<p>Implementing the effect is straightforward. <code>ServeApp</code> is directly implemented by <code>Warp.run</code>.
<code>ServeAppFromConfig</code> creates an <code>Application</code> instance based on the <code>Config</code> and then executes it with <code>Warp.run</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">ExternalInterfaces.WarpAppServer</span> <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">ExternalInterfaces.AppServer</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">ExternalInterfaces.ApplicationAssembly</span> (createApp, loadConfig)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">InterfaceAdapters.Config</span>               (<span class="dt">Config</span> (..))</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Network.Wai.Handler.Warp</span>               <span class="kw">as</span> <span class="dt">Warp</span> (run)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Polysemy</span>                               (<span class="dt">Embed</span>, <span class="dt">Member</span>, <span class="dt">Sem</span>,</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>                                                         embed, interpret, runM)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Warp Based implementation of AppServer</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="ot">runWarpAppServer ::</span> (<span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">AppServer</span> <span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>runWarpAppServer port <span class="ot">=</span> interpret <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- this is the more generic version which maps directly to Warp.run</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ServeApp</span> app <span class="ot">-&gt;</span> embed <span class="op">$</span> Warp.run port app</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- serving an application by constructing it from a config</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ServeAppFromConfig</span> config <span class="ot">-&gt;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    embed <span class="op">$</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> app <span class="ot">=</span> createApp config</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> Warp.run port app</span></code></pre></div>
<h3 id="putting-everything-together-in-a-new-main-function">Putting everything together in a new main function</h3>
<p>The <code>main</code> function now contains the outer Polysemy effect interpreter:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  config <span class="ot">&lt;-</span> loadConfig      <span class="co">-- loading the config as before</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> p <span class="ot">=</span> port config       <span class="co">-- obtain http port from config</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  serveAppFromConfig config <span class="co">-- declaring to run config based app on an AppServer</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span> runWarpAppServer p    <span class="co">-- use Warp to interprete this effect</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span> runM                  <span class="co">-- finally lower the `Sem` stack into `IO ()`</span></span></code></pre></div>
<p>Interpretation of the <em>inner</em> effect stack is still handled by <code>createApp</code> but the actual control of the complete program now lies within the control of the outer effect interpreter in the <code>main</code> function. The <code>inner</code> effect stack is executed as part of the <code>runWarpAppServer</code> Polysemy interpreter function.</p>
<h3 id="bonus-an-aws-lambda-hal-based-implementation-of-the-appserver-effect">Bonus: An AWS Lambda HAL based implementation of the AppServer effect</h3>
<p>One of the many benefits of Polysemy is that it allows to provide multiple implementations of a given effect declaration.
I’ll demonstrate this by presenting an implementation of the <code>AppServer</code> effect that allows to host our application on AWS Lambda (using <a href="https://github.com/bellroy/wai-handler-hal">wai-handler-hal</a>).</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">ExternalInterfaces.HalAppServer</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">ExternalInterfaces.AppServer</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">ExternalInterfaces.ApplicationAssembly</span> (createApp)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">InterfaceAdapters.Config</span>               (<span class="dt">Config</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">AWS.Lambda.Runtime</span>                     (mRuntime)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Network.Wai.Handler.Hal</span> <span class="kw">as</span> <span class="dt">Hal</span>         (run)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Polysemy</span>                               (<span class="dt">Embed</span>, <span class="dt">Member</span>, <span class="dt">Sem</span>,</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>                                                         embed, interpret, runM)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- | wai-handler-hal Based implementation of AppServer</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="ot">runHalAppServer ::</span> (<span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r) <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">AppServer</span> <span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>runHalAppServer <span class="ot">=</span> interpret <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ServeApp</span> app <span class="ot">-&gt;</span> embed <span class="op">$</span> mRuntime <span class="op">$</span> Hal.run app</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ServeAppFromConfig</span> config <span class="ot">-&gt;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    embed <span class="op">$</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> app <span class="ot">=</span> createApp config</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> mRuntime <span class="op">$</span> Hal.run app</span></code></pre></div>
<p>This looks very similar to the Warp implementation. The main difference is that we don’t have to deal with an http port number as this will be managed by AWS Lambda.</p>
<p>Here is an alternative main function that shows how to interprete our application with <code>runHalAppServer</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  config <span class="ot">&lt;-</span> loadConfig</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  serveAppFromConfig config</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span> runHalAppServer <span class="co">-- use HAL to run rest application</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span> runM    </span></code></pre></div>
<h3 id="conclusion">Conclusion</h3>
<p>I really like how this new approach cleans up the overall control flow and puts everything under control of the polysemy effect interpreter.
Following this way helps to make the separation between domain and use case logic from external interfaces and outward infrastructure even more distinct.</p>
<p>As an additional bonus we can now transparently execute our application on different hosting environments just by switching effect interpreter functions.</p>
]]></description>
    <pubDate>Mon, 04 Jul 2022 00:00:00 UT</pubDate>
    <guid>https://thma.github.io//posts/2022-07-04-polysemy-and-warp.html</guid>
    <dc:creator>Thomas Mahler</dc:creator>
</item>
<item>
    <title>Evaluating SKI combinators as native Haskell functions</title>
    <link>https://thma.github.io//posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html</link>
    <description><![CDATA[<div class="info">
    <em>Posted on February  5, 2022
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<p><a href="https://github.com/thma/lambda-ski/actions"><img src="https://github.com/thma/lambda-ski/workflows/Haskell-CI/badge.svg" alt="Actions Status" /></a>
<a href="https://github.com/thma/lambda-ski"><img src="https://thma.github.io/img/forkme.png" height="20" ></a></p>
<h2 id="abstract">Abstract</h2>
<p>In this post I present an alternative approach to combinator-based implementation of functional languages that is significantly faster than classical graph-reduction based solutions.</p>
<p>As this approach makes use of combinator reduction directly implemented as Haskell functions it is also much simpler and smaller in size than explicit graph-reduction.</p>
<h2 id="introduction">Introduction</h2>
<p>In a <a href="https://thma.github.io/posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html">previous post</a> I presented a classical approach to implement a functional language with combinator based graph-reduction in Haskell.</p>
<p>The implementation was structured into three parts:</p>
<ol type="1">
<li><p>A parser for a tiny functional language based on the untyped λ-calculus.</p></li>
<li><p>A small compiler from λ-calculus to a fixed set of combinatory logic combinators (S,K,I,B,C and Y (aka. SICKBY)).</p></li>
<li><p>A graph-reduction engine which implements the combinator rewrite rules as an efficient graph reduction</p></li>
</ol>
<p>The basic idea is as follows:</p>
<p>Take a program like <code>main = (\x y -&gt; x) 3 4</code> and compile it to a variable-free combinator expressions, in this case <code>K 3 4</code>.
Then apply the combinator reduction rules like <code>K x y = x</code> until normal-form is reached.</p>
<p>Graph-reduction is used as an efficient implementation technique for these reduction rules.
For example the reduction of <code>K</code> is implemented as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">reduce ::</span> <span class="dt">Combinator</span> <span class="ot">-&gt;</span> <span class="dt">LeftAncestorsStack</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- K x y = x</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>reduce <span class="dt">K</span> (p1 <span class="op">:</span> p2 <span class="op">:</span> _) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  (_K <span class="op">:@:</span> xP) <span class="ot">&lt;-</span> readSTRef p1</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  xVal <span class="ot">&lt;-</span> readSTRef xP</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  writeSTRef p2 xVal</span></code></pre></div>
<p>This code transforms the graph by directly writing the value <code>xVal</code>, stored in <code>xP</code> into the root node <code>p2</code>, as depicted below:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>p2<span class="op">:</span>    <span class="op">@</span>   <span class="op">==&gt;</span>  <span class="dv">3</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>      <span class="op">/</span> \</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>p1<span class="op">:</span>  <span class="op">@</span>   <span class="dv">4</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">/</span> \</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">K</span>   <span class="dv">3</span></span></code></pre></div>
<p>In this post I’m looking for an alternative backend that can replace the graph-reduction engine.</p>
<h2 id="gaining-a-new-perspective">Gaining a new perspective</h2>
<p>The SICKBY combinators can be defined as ordinary Haskell functions:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>i x      <span class="ot">=</span> x         <span class="co">-- i = id</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>k x y    <span class="ot">=</span> x         <span class="co">-- k = const</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>s f g x  <span class="ot">=</span> f x (g x)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>c f g x  <span class="ot">=</span> ((f x) g)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>b f g x  <span class="ot">=</span> (f (g x))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>y        <span class="ot">=</span> fix</span></code></pre></div>
<p>So why don’t we just use the Haskell native implementations of these combinators to reduce our expressions <code>implicitely</code>,
rather than building our own graph reduction to <code>explicitly</code> reduce them?</p>
<p>It turns out that Matthew Naylor already wrote about this idea more than a decade ago in <a href="https://wiki.haskell.org/wikiupload/0/0a/TMR-Issue10.pdf">The Monad Reader, issue 10</a> (see also this <a href="https://smunix.github.io/kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html">more recent coverage of the idea</a>).</p>
<p>In the following section I will walk you through the details of this concept.</p>
<h2 id="translating-sickby-expressions">Translating SICKBY expressions</h2>
<p>In order to make use of Haskell functions to implement combinator reduction we’ll first need a data structure that allows to include native functions in addition to the actual terms:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">LambdaToSKI</span> (<span class="dt">Combinator</span> (..), fromString)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- | a compiled expression may be:</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">CExpr</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">CComb</span> <span class="dt">Combinator</span>       <span class="co">-- a known combinator symbol</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">CApp</span> <span class="dt">CExpr</span> <span class="dt">CExpr</span>       <span class="co">-- an application (f x)</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">CFun</span> (<span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span>)  <span class="co">-- a native haskell function of type (CExpr -&gt; CExpr)</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">CInt</span> <span class="dt">Integer</span>           <span class="co">-- an integer</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- | declaring a show instance for CExpr</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">CExpr</span> <span class="kw">where</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">CComb</span> k)  <span class="ot">=</span> <span class="fu">show</span> k</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">CApp</span> a b) <span class="ot">=</span> <span class="st">&quot;(&quot;</span> <span class="op">++</span> <span class="fu">show</span> a <span class="op">++</span> <span class="st">&quot; &quot;</span> <span class="op">++</span> <span class="fu">show</span> b <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">CFun</span> _f)  <span class="ot">=</span> <span class="st">&quot;&lt;function&gt;&quot;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">CInt</span> i)   <span class="ot">=</span> <span class="fu">show</span> i</span></code></pre></div>
<p>Translation from SICKBY terms (that is abstracted lambda expresssions) to <code>CExpr</code> is straightforward:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | translating an abstracted lambda expression into a compiled expression</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">translate ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>translate (fun <span class="op">:@</span> arg)   <span class="ot">=</span> <span class="dt">CApp</span> (translate fun) (translate arg)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>translate (<span class="dt">Int</span> k)        <span class="ot">=</span> <span class="dt">CInt</span> k</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>translate (<span class="dt">Var</span> c)        <span class="ot">=</span> <span class="dt">CComb</span> (fromString c)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>translate lam<span class="op">@</span>(<span class="dt">Lam</span> _ _)  <span class="ot">=</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;lambdas should already be abstracted: &quot;</span> <span class="op">++</span> <span class="fu">show</span> lam</span></code></pre></div>
<ol type="1">
<li>Applications are translated by forming a <code>CApp</code> of the translated function and it’s argument.</li>
<li>Integers are kept as is, just wrapped with a <code>CInt</code> constructor</li>
<li>After performing bracket abstraction any remaining <code>Var</code> must be a combinator. They are thus translated into a fixed combinator symbol; <code>fromString</code> looks up combinator symbols.</li>
<li>After bracket abstraction any remaining <code>Lam</code> expressions would be an error, so we treat it as such.</li>
</ol>
<p>Please note that we do not use the <code>CFun</code> constructor in the translate stage. So right now the result of <code>translate</code> is just an ordinary data structure. Let’s see an example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> testSource <span class="ot">=</span> <span class="st">&quot;main = (\\x y -&gt; x) 3 4&quot;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> env <span class="ot">=</span> parseEnvironment testSource</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> compile env babs0</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>(((<span class="dt">Var</span> <span class="st">&quot;s&quot;</span> <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;k&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;k&quot;</span>)) <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;i&quot;</span>) <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">3</span>) <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">4</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> cexpr <span class="ot">=</span> translate expr</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> cexpr</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>((((<span class="dt">S</span> (<span class="dt">K</span> <span class="dt">K</span>)) <span class="dt">I</span>) <span class="dv">3</span>) <span class="dv">4</span>)</span></code></pre></div>
<p>Now it’s time to do the real work. We will have to perform two essential transformations:</p>
<ol type="1">
<li><p>All combinators of the form <code>(CComb comb)</code> have to be replaced by the haskell functions implementing the combinator reduction rule.</p></li>
<li><p>All applications <code>(CApp fun arg)</code> have to be replaced by actual function application.
In our case we want apply functions of type <code>CExpr -&gt; CExpr</code> that are wrapped by a <code>CFun</code> constructor. For this particular case we define an application operator <code>(!)</code> as follows:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | apply a CExpr of shape (CFun f) to argument x by evaluating (f x)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">0</span> <span class="op">!</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">(!) ::</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>(<span class="dt">CFun</span> f) <span class="op">!</span> x <span class="ot">=</span> f x</span></code></pre></div></li>
</ol>
<p>Both tasks are performed by the following <code>link</code> function:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | a global environment of combinator definitions</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">GlobalEnv</span> <span class="ot">=</span> [(<span class="dt">Combinator</span>,<span class="dt">CExpr</span>)]</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- | &quot;link&quot; a compiled expression into Haskell native functions.</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">--   application terms will be transformed into (!) applications</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">--   combinator symbols will be replaced by their actual function definition</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="ot">link ::</span> <span class="dt">GlobalEnv</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>link globals (<span class="dt">CApp</span> fun arg) <span class="ot">=</span> link globals fun <span class="op">!</span> link globals arg</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>link globals (<span class="dt">CComb</span> comb)   <span class="ot">=</span> fromJust <span class="op">$</span> <span class="fu">lookup</span> comb globals</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>link _globals expr          <span class="ot">=</span> expr</span></code></pre></div>
<p>The global set of combinators is defined as follows:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">primitives ::</span> <span class="dt">GlobalEnv</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>primitives <span class="ot">=</span> <span class="kw">let</span> (<span class="op">--&gt;</span>) <span class="ot">=</span> (,) <span class="kw">in</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  [ <span class="dt">I</span>      <span class="op">--&gt;</span> <span class="dt">CFun</span> <span class="fu">id</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">K</span>      <span class="op">--&gt;</span> <span class="dt">CFun</span> (<span class="dt">CFun</span> <span class="op">.</span> <span class="fu">const</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">S</span>      <span class="op">--&gt;</span> <span class="dt">CFun</span> (\f <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \g <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> f<span class="op">!</span>x<span class="op">!</span>(g<span class="op">!</span>x))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">B</span>      <span class="op">--&gt;</span> <span class="dt">CFun</span> (\f <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \g <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> f<span class="op">!</span>(g<span class="op">!</span>x))</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">C</span>      <span class="op">--&gt;</span> <span class="dt">CFun</span> (\f <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \g <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> f<span class="op">!</span>x<span class="op">!</span>g)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">IF</span>     <span class="op">--&gt;</span> <span class="dt">CFun</span> (\(<span class="dt">CInt</span> cond) <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \thenExp <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \elseExp <span class="ot">-&gt;</span> </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>                                        <span class="kw">if</span> cond <span class="op">==</span> <span class="dv">1</span> <span class="kw">then</span> thenExp <span class="kw">else</span> elseExp)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">Y</span>      <span class="op">--&gt;</span> <span class="dt">CFun</span> (\(<span class="dt">CFun</span> f) <span class="ot">-&gt;</span> fix f)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">ADD</span>    <span class="op">--&gt;</span> arith (<span class="op">+</span>)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">SUB</span>    <span class="op">--&gt;</span> arith (<span class="op">-</span>)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">SUB1</span>   <span class="op">--&gt;</span> <span class="dt">CFun</span> sub1</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">MUL</span>    <span class="op">--&gt;</span> arith (<span class="op">*</span>)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">EQL</span>    <span class="op">--&gt;</span> arith eql</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">GEQ</span>    <span class="op">--&gt;</span> arith geq</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">ZEROP</span>  <span class="op">--&gt;</span> <span class="dt">CFun</span> isZero</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="ot">arith ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">CExpr</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>arith op <span class="ot">=</span> <span class="dt">CFun</span> <span class="op">$</span> \(<span class="dt">CInt</span> a) <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \(<span class="dt">CInt</span> b) <span class="ot">-&gt;</span> <span class="dt">CInt</span> (op a b)</span></code></pre></div>
<p>As you can see, the combinators are implemented as <code>CFun</code> wrapped functions. So they bear some minor overhead for pattern matching the <code>CFun</code> constructor when using the <code>(!)</code> operator. But apart from that, they are ordinary Haskell functions.</p>
<p>Trying out <code>link</code> in GHCi looks like follows:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> link primitives cexpr</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span></code></pre></div>
<p>So our initial expression <code>main = (\\x y -&gt; x) 3 4</code> got translated into a haskell function applied to it’s two arguments. As the function is fully saturated, the ghci implicit <code>show</code> request triggers its evaluation and we see the correct result <code>3</code> returned.</p>
<h2 id="we-can-still-do-better">We can still do better</h2>
<p>I took the idea of having two passes, <code>translate</code> and <code>link</code> to transform the input SICKBY expressions verbatim from Matthew Naylor’s paper. I think it’s easier to explain the overall idea when breaking it down into these two separate steps. But it’s perfectly possible do the transformation in one pass:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | translate and link in one go</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   application terms will directly be transformed into (!) applications</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   combinator symbols will be replaced by their actual function definition</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="ot">transLink ::</span> <span class="dt">GlobalEnv</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>transLink globals (fun <span class="op">:@</span> arg)  <span class="ot">=</span> transLink globals fun <span class="op">!</span> transLink globals arg</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>transLink _globals (<span class="dt">Int</span> k)      <span class="ot">=</span> <span class="dt">CInt</span> k</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>transLink globals (<span class="dt">Var</span> c)       <span class="ot">=</span> fromJust <span class="op">$</span> <span class="fu">lookup</span> (fromString c) globals</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>transLink _globals l<span class="op">@</span>(<span class="dt">Lam</span> _ _)  <span class="ot">=</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;lambdas should be abstracted already &quot;</span> <span class="op">++</span> <span class="fu">show</span> l</span></code></pre></div>
<p>In this case the <code>CExpr</code> type becomes even simpler, as no intermediate constructors are required for applications and combinators:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | a compiled expression</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">CExpr</span> <span class="ot">=</span> </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">CFun</span> (<span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">CInt</span> <span class="dt">Integer</span></span></code></pre></div>
<h2 id="the-good-new-and-the-good-news">The good new and the good news</h2>
<p>If you studied <a href="(https://thma.github.io/posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html)">my post on the roll your own graph-reduction idea</a> you will be amazed how much simpler the current approach is.</p>
<p>But it is also tremendously faster!</p>
<p>I’ve assembled a set of <a href="https://github.com/thma/lambda-ski/blob/main/benchmark/ReductionBenchmarks.hs">criterion micro-benchmarks for some typical recursive functions</a> on integers.</p>
<p>The table below compares the mean execution times for reducing the same program with GraphReduction and with the “combinators as native functions”. the third column gives the ratio between both execution times:</p>
<table style="width:100%;">
<colgroup>
<col style="width: 1%" />
<col style="width: 44%" />
<col style="width: 40%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr>
<th></th>
<th style="text-align: right;">SICKBY GraphReduction [μs]</th>
<th style="text-align: right;">SICKBY as functions [μs]</th>
<th style="text-align: right;">ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/thma/lambda-ski/blob/main/test/factorial.ths">factorial</a></td>
<td style="text-align: right;">1273</td>
<td style="text-align: right;">24.92</td>
<td style="text-align: right;">51</td>
</tr>
<tr>
<td><a href="https://github.com/thma/lambda-ski/blob/main/test/fibonacci.ths">fibonacci</a></td>
<td style="text-align: right;">484</td>
<td style="text-align: right;">50.70</td>
<td style="text-align: right;">10</td>
</tr>
<tr>
<td><a href="https://github.com/thma/lambda-ski/blob/main/test/ackermann.ths">ackermann</a></td>
<td style="text-align: right;">386</td>
<td style="text-align: right;">16,88</td>
<td style="text-align: right;">23</td>
</tr>
<tr>
<td><a href="https://github.com/thma/lambda-ski/blob/main/test/gaussian.ths">gaussian sum</a></td>
<td style="text-align: right;">1414</td>
<td style="text-align: right;">16,18</td>
<td style="text-align: right;">87</td>
</tr>
<tr>
<td><a href="https://github.com/thma/lambda-ski/blob/main/test/tak.ths">tak</a></td>
<td style="text-align: right;">3204</td>
<td style="text-align: right;">75,69</td>
<td style="text-align: right;">42</td>
</tr>
</tbody>
</table>
<p>For the fibonacci function the “combinators as native functions” approach is ten times faster, for the gaussian sum almost 90 times.</p>
<h2 id="room-for-further-improvements">Room for further improvements</h2>
<p>It’s interesting to see how the “combinators as native functions” execution performs in comparison to actual Haskell implementations of our five test functions. The Haskell native implementations can be found in the <a href="https://github.com/thma/lambda-ski/blob/main/benchmark/ReductionBenchmarks.hs">benchmark definition</a>.</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align: right;">SICKBY as functions [μs]</th>
<th style="text-align: right;">Haskell native [μs]</th>
<th style="text-align: right;">ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>factorial</td>
<td style="text-align: right;">24.92</td>
<td style="text-align: right;">4.743</td>
<td style="text-align: right;">5</td>
</tr>
<tr>
<td>fibonacci</td>
<td style="text-align: right;">50.70</td>
<td style="text-align: right;">2.824</td>
<td style="text-align: right;">18</td>
</tr>
<tr>
<td>ackermann</td>
<td style="text-align: right;">16,88</td>
<td style="text-align: right;">0.497</td>
<td style="text-align: right;">34</td>
</tr>
<tr>
<td>gaussian sum</td>
<td style="text-align: right;">16,18</td>
<td style="text-align: right;">1.302</td>
<td style="text-align: right;">12</td>
</tr>
<tr>
<td>tak</td>
<td style="text-align: right;">75,69</td>
<td style="text-align: right;">0.084</td>
<td style="text-align: right;">903</td>
</tr>
</tbody>
</table>
<p>For simple unary function like <code>factorial</code> and <code>gaussian sum</code> the native implementation is only 5 to 12 times faster. That’s not bad for such a simple approach!</p>
<p>But for more complex functions like <code>fibonacci</code> and in particular for binary or ternary functions like <code>ackermann</code> and <code>tak</code> the performance is not that good.</p>
<p>This is caused by the inefficient “code generation” of the classic bracket abstraction: <a href="https://tromp.github.io/cl/LC.pdf">The output size grows quadratic</a> with internal complexity and number of variables. As each additional combinator or application will require additional execution time it’s easy to see why a quadratic growth in combinator code size will drastically decrease performance.
There have been many attempts to optimize bracket abstraction by <a href="https://www.cantab.net/users/antoni.diller/brackets/intro.html">introducing additional combinators</a> and by <a href="https://tromp.github.io/cl/LC.pdf">applying additional optimization rules</a>.</p>
<p>I leave it as an exercise to the interested reader to improve the bracket abstraction rules applied here in order to sigificantly speed up both the graph-reduction as the “combinators as native functions” implementations.</p>
]]></description>
    <pubDate>Sat, 05 Feb 2022 00:00:00 UT</pubDate>
    <guid>https://thma.github.io//posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html</guid>
    <dc:creator>Thomas Mahler</dc:creator>
</item>
<item>
    <title>Writing a Wiki Server with Yesod</title>
    <link>https://thma.github.io//posts/2022-01-09-Writing-a-Wiki-Server-with-Yesod.html</link>
    <description><![CDATA[<div class="info">
    <em>Posted on January  9, 2022
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<a href="https://github.com/thma/HsWiki/actions"><img src="https://github.com/thma/HsWiki/workflows/Haskell%20CI/badge.svg" alt="Actions Status" /></a>
<a href="https://github.com/thma/HsWiki"><img src="https://thma.github.io/img/forkme.png" height="20"></a>
</p>
<h2 id="abstract">Abstract</h2>
<p>In this blog post I’m presenting an implementation of a Wiki System
in the spirit of the legendary <a href="http://wiki.c2.com/">C2-Wiki</a> - written in Haskell with the <a href="https://www.yesodweb.com/">Yesod</a> framework.</p>
<p>There will also be some nice add-ons like a graphical representation of the page links.</p>
<h2 id="introduction">Introduction</h2>
<blockquote>
<p>The WikiWikiWeb is the first wiki, or user-editable website. It was launched on 25 March 1995 by its inventor, programmer Ward Cunningham, to accompany the Portland Pattern Repository website discussing software design patterns.</p>
<p><a href="https://en.wikipedia.org/wiki/WikiWikiWeb">cited from Wikipedia</a></p>
</blockquote>
<p>The <a href="http://wiki.c2.com/">WikiWikiWeb</a> was the earliest incarnation of a collaborative hypertext platform on the internet.
It started with a small set of features which proved to provide the essential tools required to create a large content
base with a dense hyperlink structure.
Editing and creating new pages was extremely simple which fostered free contributions and a high frequency of
interactions between participants.</p>
<p>The most prominent features are:</p>
<ul>
<li>A tiny markup language allows basic adjustments of typography and layout.</li>
<li>All content is rendered as HTML and thus allow easy navigation with any web browser.</li>
<li>An inplace editor allows adhoc creation and editing of pages.
On saving edited content, the page switches back to display mode, which renders the markup as HTML.</li>
<li>WikiWords, that is Text in PascalCase or <a href="https://en.wikipedia.org/wiki/Camel_case">Upper Camel Case</a> are interpreted as
hyperlinks. If such a hyperlink does not link to an existing page, the editor is opened for creating a new page.
This mechanism allows to create hyperlinked content in a very fast manner.</li>
<li>Clicking on a Page Title will display a list of all references to the current page.
This allows to identify related topics and also to organize semantic networks by creating category pages
that just keep links to all pages in the category <a href="http://wiki.c2.com/?CategoryCategory">CategoryCategory</a></li>
<li>The RecentChanges page shows the latest creation and edits to pages and thus makes it easy to identify hot topics</li>
<li>There is a full text search available.</li>
</ul>
<p>In the following I’m going to explain how I implemented each of those features.</p>
<h2 id="a-simple-markup-language-just-use-markdown">A simple markup language: Just use Markdown</h2>
<p>The original WikiWikiWeb markup language provided basic syntax for layouting text content.
Modern markup languages like Markdown are a more convenient to use, provide much more features and are already widely used.
So I’m going to use Markdown instead of the original markup language.</p>
<h2 id="rendering-content-as-html">Rendering content as HTML</h2>
<p>Yesod comes with a set of <a href="https://www.yesodweb.com/book/shakespearean-templates">templating mechanisms</a> that ease the generation of HTML, CSS and Javascript for dynamic web content. The HTML templating is backed by the <a href="https://hackage.haskell.org/package/blaze-html">Blaze Html generator</a>. Thus Yesod is optimized to use <a href="https://hackage.haskell.org/package/blaze-html">Blaze</a> for HTML content. If, for example, the Blaze <code>Html</code> data type is returned from route-handlers, Yesod will automatically set the Content-Type to <code>text/html</code>.</p>
<p>So my basic idea is to use a Markdown renderer that can output Blaze <code>Html</code>-data and let Yesod do all the heavy lifting.</p>
<p>I’m using the <a href="https://hackage.haskell.org/package/cmark-gfm">cmark-gfm</a> library to render (GitHub flavoured) Markdown content to HTML.
In order to output <code>Html</code>-data, my <code>renderMdToHtml</code> function has to look like follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">CMarkGFM</span>        (commonmarkToHtml)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Data.Text</span>       (<span class="dt">Text</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span>           <span class="dt">Text.Blaze.Html</span> (<span class="dt">Html</span>, preEscapedToHtml)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ot">renderMdToHtml ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Html</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>renderMdToHtml <span class="ot">=</span> preEscapedToHtml <span class="op">.</span> commonmarkToHtml [] []</span></code></pre></div>
<h2 id="inplace-content-editing">Inplace Content Editing</h2>
<h3 id="type-safe-page-names">Type safe page names</h3>
<p>In order to work with the wiki page names in a type safe manner we first introduce a newtype <code>PageName</code>.
In order to make sure that only proper <a href="https://en.wikipedia.org/w/index.php?title=WikiWord">WikiWords</a> can be used as page names I’m using a <a href="https://wiki.haskell.org/Smart_constructors">smart constructor</a> <code>pageName</code> which only constructs a <code>PageName</code>instance if the intented page name matches the <code>wikiWordMatch</code> regular expression:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">PageName</span> <span class="ot">=</span> <span class="dt">Page</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Read</span>, <span class="dt">Show</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ot">pageName ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">PageName</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>pageName name <span class="ot">=</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> isWikiWord name</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Page</span> name)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="dt">Nothing</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- | checks if a given Text is a WikiWord</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="ot">isWikiWord ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>isWikiWord pageName <span class="ot">=</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> find wikiWordMatch pageName <span class="kw">of</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> _  <span class="ot">-&gt;</span> <span class="dt">True</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- | the magic WikiWord Regex</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="ot">wikiWordMatch ::</span> <span class="dt">Regex</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>wikiWordMatch <span class="ot">=</span> <span class="st">&quot;([A-Z][a-z0-9]+){2,}&quot;</span>    </span></code></pre></div>
<h3 id="the-yesod-routes-for-the-editor">The Yesod routes for the editor</h3>
<p>The following <code>PathPiece</code> instance declaration is required to use the <code>PageName</code> as part of a Yesod route definition:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">PathPiece</span> <span class="dt">PageName</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  toPathPiece page   <span class="ot">=</span> asText page</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  fromPathPiece text <span class="ot">=</span> pageName text</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="ot">asText ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>asText (<span class="dt">Page</span> name) <span class="ot">=</span> name</span></code></pre></div>
<p>Again the usage of the <code>pageName</code> smart constructor ensures that only proper WikiWord pagenames are constructed.</p>
<p>Here comes the <a href="https://www.yesodweb.com/book/basics#basics_routing">Yesod route definition</a> for displaying and editing of wiki pages:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">HsWiki</span> <span class="ot">=</span> <span class="dt">HsWiki</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> contentDir ::</span> <span class="dt">String</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>mkYesod <span class="st">&quot;HsWiki&quot;</span> [parseRoutes|</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>/#PageName      PageR     GET             -- (1)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>/edit/#PageName EditR     GET POST        -- (2)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>|]</span></code></pre></div>
<p>Definition (1) can be read as follows: for any <code>PageName</code> that is accessed via a HTTP GET a route PageR is defined, which (according to the rules of the Yesod routing DSL) requires us to implement a function with the following signature:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getPageR ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span></code></pre></div>
<p>This function will have to lookup an existing page, render its Markdown content to Html and return it a <code>Handler Html</code> object. We’ll have a look at this function shortly.</p>
<p>The definition (2) states that for any route /edit/<code>PageName</code> two functions must be defined, one for GET one for POST:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getEditR  ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">postEditR ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span></code></pre></div>
<p>If you want to know how exactly handler function are invoked from the Yesod framework and how the route dispatching works, please have a look at the excellent <a href="https://www.yesodweb.com/book/">Yesod documentation</a> which features a complete walkthrough with a HelloWorld application.</p>
<h3 id="serving-an-editor">Serving an editor</h3>
<p>Now let’s study the implementation of these two function step by step, first the GET handler:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | handler for GET /edit/#PageName</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">getEditR ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>getEditR pageName <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  path <span class="ot">&lt;-</span> getDocumentRoot                    <span class="co">-- obtain path to document root </span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> fileName <span class="ot">=</span> fileNameFor path pageName   <span class="co">-- construct a file from the page name</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  exists <span class="ot">&lt;-</span> liftIO <span class="op">$</span> doesFileExist fileName  <span class="co">-- check whether file already exists</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  markdown <span class="ot">&lt;-</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> exists</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> liftIO <span class="op">$</span> TIO.readFile fileName    <span class="co">-- if file exists, assign markdown with file content</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="fu">return</span> newPage                    <span class="co">-- else assign markdown with default content</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> buildEditorFor pageName markdown  <span class="co">-- return Html for an Editor page</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- | retrieve the name of the HsWiki {contentDir} attribute, defaults to &#39;content&#39;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="ot">getDocumentRoot ::</span> <span class="dt">Handler</span> <span class="dt">String</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>getDocumentRoot <span class="ot">=</span> getsYesod contentDir  </span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- | construct the proper file name for a PageName</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="ot">fileNameFor ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">PageName</span>  <span class="ot">-&gt;</span> <span class="dt">FilePath</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>fileNameFor path pageName <span class="ot">=</span> path <span class="op">++</span> <span class="st">&quot;/&quot;</span> <span class="op">++</span> asString pageName <span class="op">++</span> <span class="st">&quot;.md&quot;</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- | create default content for a new page</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="ot">newPage ::</span> <span class="dt">Text</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>newPage <span class="ot">=</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>     <span class="st">&quot;Use WikiWords in PascalCase for Links. \n\n&quot;</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;&gt;</span> <span class="st">&quot;Use [Markdown](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) to format page content&quot;</span></span></code></pre></div>
<p>As we can see from the reading of markdown content from files, the idea is to just keep all pages as static content files in the filesystem. By default these files reside in the local folder <em>content</em> (this folder can be configured by a commandline argument).</p>
<p>Next we’ll have a look at the <code>buildEditorFor</code> function that will generate the actual Html content of the editor page:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">buildEditorFor ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Html</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>buildEditorFor pageName markdown <span class="ot">=</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  toHtml</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    [ pageHeader <span class="dt">False</span>,</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>      menuBar <span class="st">&quot;&quot;</span>,</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>      renderMdToHtml <span class="op">$</span> <span class="st">&quot;# &quot;</span> <span class="op">&lt;&gt;</span> page <span class="op">&lt;&gt;</span> <span class="st">&quot; \n&quot;</span>,</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>      preEscapedToHtml <span class="op">$</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;&lt;form action=\&quot;&quot;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;&gt;</span> page</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;&gt;</span> <span class="st">&quot;\&quot; method=\&quot;POST\&quot;&gt;&quot;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;&gt;</span> <span class="st">&quot;&lt;textarea style=\&quot;height: auto;\&quot; name=\&quot;content\&quot; cols=\&quot;120\&quot; rows=\&quot;25\&quot;&gt;&quot;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;&gt;</span> markdown</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;&gt;</span> <span class="st">&quot;&lt;/textarea&gt;&quot;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;&gt;</span> <span class="st">&quot;&lt;input type=\&quot;submit\&quot; name=\&quot;save\&quot; value=\&quot;save\&quot; /&gt; &amp;nbsp; &quot;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;&gt;</span> <span class="st">&quot;&lt;input class=\&quot;button button-outline\&quot; type=\&quot;button\&quot; name=\&quot;cancel\&quot; value=\&quot;cancel\&quot; onClick=\&quot;window.history.back()\&quot; /&gt; &quot;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>          <span class="op">&lt;&gt;</span> <span class="st">&quot;&lt;/form&gt;&quot;</span>,</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>      pageFooter</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> page <span class="ot">=</span> asText pageName</span></code></pre></div>
<p>The most important element here is the creation of an Html <code>&lt;form ...&gt;...&lt;/form&gt; element. The action for that form is just the same page but with a</code>POST<code>-method (we'll come to the respective handler function</code>postEditR` shortly).</p>
<p>Now imagine we point our browser to <code>http://localhost:3000/edit/BrandNewPage</code>. Yesod will do the routing to <code>getEditR (Page "BrandNewPage")</code> and the generated Html for editing a new page ‘BrandNewPage’ will be sent back to the browser. The page will look like this:</p>
<figure>
<img src="../img/editor.png" alt="The Editor for a new page" />
<figcaption aria-hidden="true">The Editor for a new page</figcaption>
</figure>
<p>As we can see, I’ve applied some basic CSS styling <a href="https://milligram.io/">(using Milligram CSS)</a>. This is done in the <code>pageHeader</code> function.</p>
<h3 id="processing-the-posting-of-data">processing the posting of data</h3>
<p>The editor has two buttons, <em>SAVE</em> and <em>CANCEL</em>. On cancel we just navigate back to the previous page in the browser history. On save the browser sends the form data via the <code>POST</code> method to the server. To handle this incoming POST-request we’ll the <code>postEditR</code> handler function:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">postEditR ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>postEditR pageName <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  path <span class="ot">&lt;-</span> getDocumentRoot                    <span class="co">-- obtain path to document root</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> fileName <span class="ot">=</span> fileNameFor path pageName   <span class="co">-- construct a file from the page name</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  maybeContent <span class="ot">&lt;-</span> lookupPostParam <span class="st">&quot;content&quot;</span>  <span class="co">-- retrieve POST data</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  client <span class="ot">&lt;-</span> remoteHost <span class="op">&lt;$&gt;</span> waiRequest        <span class="co">-- retrieve info on remote client from request</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> maybeContent <span class="kw">of</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> content <span class="ot">-&gt;</span> liftIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>      TIO.writeFile fileName content         <span class="co">-- if content exists write it to disk</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>      writeLogEntry path pageName client     <span class="co">-- also write a log entry to file RecentChanges</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()                     <span class="co">-- no content: do nothing</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  redirect <span class="op">$</span> <span class="dt">PageR</span> pageName                  <span class="co">-- redirect to GET Page route (display content)</span></span></code></pre></div>
<p>So essentially we are just writing the markdown content into a file. After that we redirect to
the <code>PageR</code> route. This will result in redirecting the browser to <code>http://localhost:3000/BrandNewPage</code>. As you can see in the following screen-shot the markdown content that was entered in the editor form is now rendered as HTML:</p>
<figure>
<img src="../img/renderPage.png" alt="render an existing page" />
<figcaption aria-hidden="true">render an existing page</figcaption>
</figure>
<h3 id="rendering-page-content">rendering page content</h3>
<p>As promised above we’ll now have a closer look at the <code>getPageR</code> route handler function:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Handler for GET /#PageName</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">getPageR ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>getPageR pageName <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  path <span class="ot">&lt;-</span> getDocumentRoot                            <span class="co">-- obtain path to document root </span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  maybeShowRefs <span class="ot">&lt;-</span> lookupGetParam <span class="st">&quot;showBackrefs&quot;</span>     <span class="co">-- check whether URL ends with &#39;?showBackrefs&#39;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  maybeBackrefs <span class="ot">&lt;-</span> liftIO <span class="op">$</span>                          <span class="co">-- if showBackrefs was set, Just [PageName] </span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    computeMaybeBackrefs path pageName maybeShowRefs <span class="co">-- else Nothing</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> fileName <span class="ot">=</span> fileNameFor path pageName           <span class="co">-- compute proper filename from pageName</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  exists <span class="ot">&lt;-</span> liftIO <span class="op">$</span> doesFileExist fileName          <span class="co">-- check whether such a file exists</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> exists</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="kw">do</span>                                                                  </span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>      content <span class="ot">&lt;-</span> liftIO <span class="op">$</span> TIO.readFile fileName      <span class="co">-- file exists, read its content</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> <span class="op">$</span> buildViewFor </span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        pageName content maybeBackrefs               <span class="co">-- build HTML for content and return it</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>      redirect <span class="op">$</span> <span class="dt">EditR</span> pageName                      <span class="co">-- file does not exist, redirect to EditR</span></span></code></pre></div>
<p>Let’s ignore the lines with <code>maybeShowRefs</code> and <code>maybeBackrefs</code> for a moment. We just assume that <code>maybeBackrefs == Nothing</code>. So we first check whether a file exists for the given <code>pageName</code>. If yes, the file-content is read and bound to <code>content</code>; next we build a HTML view for the page with <code>buildViewFor</code> and return it. If no file was found matching <code>pageName</code> we redirect directly to the <code>EditR</code>which will in turn open up an editor for an empty page as already shown in the previous section.</p>
<p>Let’s have a closer look at <code>buildViewFor</code>. It will first evaluate the <code>maybeBackrefs</code> arguments. For the moment let’s assume equals <code>Nothing</code>, so that <code>hasBackref</code> is bound to <code>True</code> and <code>backrefEntry</code> to <code>""</code>.</p>
<p>Then the actual HTML for the page is constructed from a set of template functions:
- <code>pageHeader</code> creates the HTML head with css definitions,
- <code>menuBar</code> creates the menu line on top of the page,
- <code>pageTitle</code> creates a headline from the <code>pageName</code>,
- <code>backrefEntry</code> is just empty text in this scenario
- <code>renderMdToHtml (wikiWordToMdLink content)</code> first replaces all ocurrences of <em>WikiWords</em> with proper Markdown hyperlinks of the form <code>[WikiWord](WikiWord)</code> the result is then rendered to HTML (this is the single place where we convert from <em>WikiWords</em> to hyperlinks and thus make the Wiki magic happen…),
- finally <code>pageFooter</code> closes all open html tags:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">buildViewFor ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">PageName</span>] <span class="ot">-&gt;</span> <span class="dt">Html</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>buildViewFor pageName content maybeBackrefs <span class="ot">=</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (hasBackref, backrefEntry) <span class="ot">=</span> <span class="kw">case</span> maybeBackrefs <span class="kw">of</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Nothing</span>       <span class="ot">-&gt;</span> (<span class="dt">False</span>, text <span class="st">&quot;&quot;</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> backrefs <span class="ot">-&gt;</span> (<span class="dt">True</span>, renderedBackrefs)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>          <span class="kw">where</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="ot">            concatMap ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Text</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            <span class="fu">concatMap</span> <span class="ot">=</span> (T.intercalate <span class="st">&quot;&quot;</span> <span class="op">.</span>) <span class="op">.</span> <span class="fu">map</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            renderedBackrefs <span class="ot">=</span> renderMdToHtml <span class="op">$</span> <span class="fu">concatMap</span> ((\b <span class="ot">-&gt;</span> <span class="st">&quot;- [&quot;</span> <span class="op">&lt;&gt;</span> b <span class="op">&lt;&gt;</span> <span class="st">&quot;](/&quot;</span> <span class="op">&lt;&gt;</span> b <span class="op">&lt;&gt;</span> <span class="st">&quot;) \n&quot;</span>) <span class="op">.</span> asText) backrefs</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> toHtml [pageHeader <span class="dt">False</span>, </span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>              menuBar (asText pageName), </span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>              pageTitle pageName hasBackref, </span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>              backrefEntry, </span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>              renderMdToHtml (wikiWordToMdLink content), </span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>              pageFooter]</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- | converts a WikiWord into a Markdown link: [WikiWord](WikiWord)</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="ot">wikiWordToMdLink ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>wikiWordToMdLink text <span class="ot">=</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> match <span class="ot">=</span> wikiWordMatch</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>      replace <span class="ot">=</span> <span class="st">&quot;[$0]($0)&quot;</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> replaceAll match replace text              </span></code></pre></div>
<h2 id="displaying-back-links-aka-reverse-index-for-each-page">Displaying back links (aka reverse index) for each page</h2>
<p>Another important feature of the original WikiWiki was the seamless integration of back links:</p>
<blockquote>
<p>If page A links to page B, then a ‘back link’ would be a link which goes from page B back to page A.</p>
<p>On this wiki, the title of each page works as a back link. Clicking on the title of any page finds all the pages referring to that page. It works for any wiki page. E.g. to find all pages that link to this page, click the title at the top of this page.</p>
<p><a href="http://wiki.c2.com/?BackLink">quoted from the WikiWiki</a></p>
</blockquote>
<p>This feature can best be demonstrated with an example. First we lookup up page <code>http://localhost:3000/CategoryMammal</code>, a page meant to represent the class of all mammaĺ animals:</p>
<figure>
<img src="../img/CategoryMammal.png" alt="normal view of a category page" />
<figcaption aria-hidden="true">normal view of a category page</figcaption>
</figure>
<p>The headline of this page is a hyperlink which references <code>http://localhost:3000/CategoryMammal?showBackrefs</code>. Following the link results in the following page:</p>
<figure>
<img src="../img/CategoryMammalWithBackLinks.png" alt="the category page with the listing of back references" />
<figcaption aria-hidden="true">the category page with the listing of back references</figcaption>
</figure>
<p>Now we see a bullet point list of all pages linking to <em>CategoryMammal</em> above the normal page content. Following one of these links, e.g. <code>http://localhost:3000/SpeciesCat</code>, leads to the following page:</p>
<figure>
<img src="../img/SpeciesCat.png" alt="a wiki page referencing to the category page" />
<figcaption aria-hidden="true">a wiki page referencing to the category page</figcaption>
</figure>
<p>At the bottom of this page we see the <em>WikiWord</em> CategoryMammal. This is interpreted as a link from <em>SpeciesCat</em> to <em>CategoryMammal</em>. And as a result the back-link display on page <em>CategoryMammal</em> contains a link to <em>SpeciesCat</em>.</p>
<p>Let’s see how this works on the code level. In fact we already came across this mechanism but had skipped over it for the time being. Now it’s time to revisit. We start with the <code>getPageR</code> function.</p>
<p>In our scenario a click on the link <code>http://localhost:3000/CategoryMammal?showBackrefs</code> leads to a call to <code>getPageR</code>. But this time <code>lookupGetParam "showBackrefs"</code> will succeed and thus now <code>maybeShowRefs</code> is bound to <code>Just ""</code>. This will lead to a different execution path in the call to <code>computeMaybeBackrefs</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Handler for GET /#PageName</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">getPageR ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>getPageR pageName <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  path <span class="ot">&lt;-</span> getDocumentRoot                            <span class="co">-- obtain path to document root </span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  maybeShowRefs <span class="ot">&lt;-</span> lookupGetParam <span class="st">&quot;showBackrefs&quot;</span>     <span class="co">-- check whether URL ends with &#39;?showBackrefs&#39;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  maybeBackrefs <span class="ot">&lt;-</span> liftIO <span class="op">$</span>                          <span class="co">-- if showBackrefs was set, Just [PageName] </span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    computeMaybeBackrefs path pageName maybeShowRefs <span class="co">-- else Nothing</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> fileName <span class="ot">=</span> fileNameFor path pageName           <span class="co">-- compute proper filename from pageName</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  exists <span class="ot">&lt;-</span> liftIO <span class="op">$</span> doesFileExist fileName          <span class="co">-- check whether such a file exists</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> exists</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="kw">do</span>                                                                  </span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>      content <span class="ot">&lt;-</span> liftIO <span class="op">$</span> TIO.readFile fileName      <span class="co">-- file exists, read its content</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> <span class="op">$</span> buildViewFor </span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        pageName content maybeBackrefs               <span class="co">-- build HTML for content and return it</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>      redirect <span class="op">$</span> <span class="dt">EditR</span> pageName                      <span class="co">-- file does not exist, redirect to EditR</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- | if maybeShowRefs isJust then a list of a pages referencing pageName is computed</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a><span class="ot">computeMaybeBackrefs ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> [<span class="dt">PageName</span>])</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>computeMaybeBackrefs path pageName maybeShowRefs <span class="ot">=</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> maybeShowRefs <span class="kw">of</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">Nothing</span>                      <span class="co">-- if maybeShowRefs == Nothing, return Nothing</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> _  <span class="ot">-&gt;</span> <span class="kw">do</span>                                  <span class="co">-- else compute list of all references to page by</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>      allPages <span class="ot">&lt;-</span> computeIndex path                <span class="co">-- computing list of all pages in wiki</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>      backrefs <span class="ot">&lt;-</span> computeBackRefs path pageName allPages <span class="co">-- compute all back references</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> <span class="op">$</span> <span class="dt">Just</span> backrefs                       <span class="co">-- return this list wrapped as a Maybe</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a><span class="co">-- | compute a list of all pages that contain references to pageName</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a><span class="ot">computeBackRefs ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> [<span class="dt">PageName</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">PageName</span>]</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>computeBackRefs path pageName allPages <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> filteredPages <span class="ot">=</span> delete pageName allPages   <span class="co">-- filter pagename from list of pages</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>  markRefs <span class="ot">&lt;-</span> <span class="fu">mapM</span>                               <span class="co">-- create a list of bools: True if a page contains</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">fmap</span> containsBackref <span class="op">.</span> TIO.readFile <span class="op">.</span> fileNameFor path)             <span class="co">-- a reference, else False</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>    filteredPages</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pageBoolPairs <span class="ot">=</span> <span class="fu">zip</span> filteredPages markRefs <span class="co">-- create a zipped list of (pageName, Bool) pairs</span></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">map</span> <span class="fu">fst</span> (<span class="fu">filter</span> <span class="fu">snd</span> pageBoolPairs)    <span class="co">-- return only pages marked True</span></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>    containsBackref content <span class="ot">=</span>                    <span class="co">-- returns True if content contains pageName</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>      asText pageName <span class="ot">`T.isInfixOf`</span> content</span></code></pre></div>
<p>Next we revisit <code>buildViewFor</code>. Here we see a case match on <code>maybeBackrefs</code>. In our current scenario it will
match to <code>Just backrefs</code>. Thus <code>renderedBackrefs</code> will be bound to Html generated by rendering a Markdown list of hyperlinks that is constructed from the <code>backrefs</code> list of PageNames.</p>
<p>This generated Html is then included as <code>backrefEntry</code> into the overall page layout:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">buildViewFor ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">PageName</span>] <span class="ot">-&gt;</span> <span class="dt">Html</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>buildViewFor pageName content maybeBackrefs <span class="ot">=</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (hasBackref, backrefEntry) <span class="ot">=</span> <span class="kw">case</span> maybeBackrefs <span class="kw">of</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Nothing</span>       <span class="ot">-&gt;</span> (<span class="dt">False</span>, text <span class="st">&quot;&quot;</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> backrefs <span class="ot">-&gt;</span> (<span class="dt">True</span>, renderedBackrefs)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>          <span class="kw">where</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="ot">            concatMap ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Text</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>            <span class="fu">concatMap</span> <span class="ot">=</span> (T.intercalate <span class="st">&quot;&quot;</span> <span class="op">.</span>) <span class="op">.</span> <span class="fu">map</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>            renderedBackrefs <span class="ot">=</span> </span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>              renderMdToHtml <span class="op">$</span> <span class="fu">concatMap</span> </span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>                  ((\b <span class="ot">-&gt;</span> <span class="st">&quot;- [&quot;</span> <span class="op">&lt;&gt;</span> b <span class="op">&lt;&gt;</span> <span class="st">&quot;](/&quot;</span> <span class="op">&lt;&gt;</span> b <span class="op">&lt;&gt;</span> <span class="st">&quot;) \n&quot;</span>) <span class="op">.</span> asText) </span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>                  backrefs</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> toHtml [pageHeader <span class="dt">False</span>, </span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>              menuBar (asText pageName), </span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>              pageTitle pageName hasBackref, </span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>              backrefEntry, </span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>              renderMdToHtml (wikiWordToMdLink content), </span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>              pageFooter]        </span></code></pre></div>
<h2 id="show-the-latest-creation-and-edits-to-pages">Show the latest creation and edits to pages</h2>
<p>I already covered the <code>postEditR</code> function, but I did not explain the <code>writeLogEntry</code> function which traces each change to page-content. So here comes the full picture:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">postEditR ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>postEditR pageName <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  path <span class="ot">&lt;-</span> getDocumentRoot                    <span class="co">-- obtain path to document root</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> fileName <span class="ot">=</span> fileNameFor path pageName   <span class="co">-- construct a file from the page name</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  maybeContent <span class="ot">&lt;-</span> lookupPostParam <span class="st">&quot;content&quot;</span>  <span class="co">-- retrieve POST data</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  client <span class="ot">&lt;-</span> remoteHost <span class="op">&lt;$&gt;</span> waiRequest        <span class="co">-- retrieve info on remote client from request</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> maybeContent <span class="kw">of</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> content <span class="ot">-&gt;</span> liftIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>      TIO.writeFile fileName content         <span class="co">-- if content exists write it to disk</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>      writeLogEntry path pageName client     <span class="co">-- also write a log entry to file RecentChanges</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()                     <span class="co">-- no content: do nothing</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>  redirect <span class="op">$</span> <span class="dt">PageR</span> pageName                  <span class="co">-- redirect to GET Page route (display content)</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- | write a log entry to the RecentChanges page</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="ot">writeLogEntry ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">SockAddr</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>writeLogEntry path pageName client <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> fileName <span class="ot">=</span> fileNameFor path recentChanges <span class="co">-- path to RecentChanges page</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>  now <span class="ot">&lt;-</span> getCurrentTime                         <span class="co">-- create timestamp</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> logEntry <span class="ot">=</span> toStrict <span class="op">$</span>                     <span class="co">-- create a log entry consisting of:</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>        format (<span class="st">&quot;- &quot;</span> <span class="op">%</span> string <span class="op">%</span> <span class="st">&quot; &quot;</span> <span class="op">%</span> string <span class="op">%</span> <span class="st">&quot; from &quot;</span> <span class="op">%</span> string <span class="op">%</span> <span class="st">&quot;\n&quot;</span>)</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>          (asString pageName)                   <span class="co">-- page edited/created</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>          (<span class="fu">takeWhile</span> (<span class="op">/=</span> <span class="ch">&#39;.&#39;</span>) (<span class="fu">show</span> now))       <span class="co">-- current timestamp</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>          (<span class="fu">takeWhile</span> (<span class="op">/=</span> <span class="ch">&#39;:&#39;</span>) (<span class="fu">show</span> client))    <span class="co">-- IP address of client</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>  TIO.appendFile fileName logEntry              <span class="co">-- add log entry at end of log file</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a><span class="co">-- | the RecentChanges PageName</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a><span class="ot">recentChanges ::</span> <span class="dt">PageName</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>recentChanges <span class="ot">=</span> <span class="dt">Page</span> <span class="st">&quot;RecentChanges&quot;</span></span></code></pre></div>
<p>And here comes a sample screen shot of the RecentChanges page:</p>
<figure>
<img src="../img/RecentChanges.png" alt="The RecentChanges page" />
<figcaption aria-hidden="true">The RecentChanges page</figcaption>
</figure>
<h2 id="have-a-full-text-search">Have a full text search</h2>
<p>For the full text search Iǜe provided a specific route <code>/actions/find</code> to avoid overlap with ordinary content pages:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>mkYesod <span class="st">&quot;HsWiki&quot;</span> [parseRoutes|</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>/actions/find/  FindR     GET</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>|]</span></code></pre></div>
<p>The corresponding handler function <code>getFindR</code> is defined as follows:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | handler for GET /actions/find</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">getFindR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>getFindR <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  path <span class="ot">&lt;-</span> getDocumentRoot                       <span class="co">-- obtain path to document root</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  allPages <span class="ot">&lt;-</span> liftIO <span class="op">$</span> computeIndex path        <span class="co">-- compute a list of all page names in wiki</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  maybeSearch <span class="ot">&lt;-</span> lookupGetParam <span class="st">&quot;search&quot;</span>        <span class="co">-- check whether query param &#39;search&#39; is set</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> maybeSearch <span class="kw">of</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> buildFindPage <span class="st">&quot;&quot;</span> [] <span class="co">-- if maybeSearch == Nothing or Just &quot;&quot;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> <span class="st">&quot;&quot;</span>     <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> buildFindPage <span class="st">&quot;&quot;</span> [] <span class="co">-- then return empty find page</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> search <span class="ot">-&gt;</span> <span class="kw">do</span>                           </span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>      markMatches <span class="ot">&lt;-</span> liftIO <span class="op">$</span>                   <span class="co">-- else create a list of Bools by</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        <span class="fu">mapM</span>                                    <span class="co">-- returning True for each file that matches</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>          (\p <span class="ot">-&gt;</span> <span class="fu">fmap</span> containsSearchText <span class="op">$</span>      <span class="co">-- search, else False</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>            <span class="fu">return</span> (asText p) <span class="op">&lt;&gt;</span> TIO.readFile (fileNameFor path p)) </span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>          allPages</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> pageBoolPairs <span class="ot">=</span> <span class="fu">zip</span> allPages markMatches  <span class="co">-- create a zipped list [(PageName, Bool)]</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> matchingPages <span class="ot">=</span> <span class="fu">map</span> <span class="fu">fst</span> (<span class="fu">filter</span> <span class="fu">snd</span> pageBoolPairs) <span class="co">-- filter for all matching pages</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> <span class="op">$</span> buildFindPage search matchingPages   <span class="co">-- build find page with search term and </span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span>                                       <span class="co">-- list of matching pages</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>          containsSearchText content <span class="ot">=</span> T.toLower search <span class="ot">`T.isInfixOf`</span> T.toLower content</span></code></pre></div>
<p>The <code>buildFindPage</code> function is responsible for assembling the Html view of this page.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">buildFindPage ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">PageName</span>] <span class="ot">-&gt;</span> <span class="dt">Html</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>buildFindPage search pages <span class="ot">=</span> toHtml</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  [ pageHeader <span class="dt">True</span>,</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    menuBar <span class="st">&quot;&quot;</span>,</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    renderMdToHtml <span class="st">&quot;# FindPage &quot;</span>,</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    searchBox search,</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    renderMdToHtml <span class="op">$</span> T.pack <span class="op">$</span> <span class="fu">concatMap</span> (\p <span class="ot">-&gt;</span> <span class="st">&quot;- [&quot;</span> <span class="op">++</span> asString p <span class="op">++</span> <span class="st">&quot;](/&quot;</span> <span class="op">++</span> asString p <span class="op">++</span> <span class="st">&quot;) \n&quot;</span>) pages,</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    pageFooter</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="ot">searchBox ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Html</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>searchBox search <span class="ot">=</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>  preEscapedToHtml <span class="op">$</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;&lt;script type=\&quot;text/javascript\&quot;&gt;&quot;</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;function init()&quot;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;{&quot;</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;     document.getElementById(\&quot;search\&quot;).focus();&quot;</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;}&quot;</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;&lt;/script&gt;&quot;</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;&lt;form action=\&quot;/actions/find\&quot;&quot;</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot; method=\&quot;GET\&quot;&gt;&quot;</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot;&lt;input type=\&quot;text\&quot; id=\&quot;search\&quot; name=\&quot;search\&quot; value=\&quot;&quot;</span> <span class="op">++</span> T.unpack search <span class="op">++</span> <span class="st">&quot;\&quot; &quot;</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot;onfocus=\&quot;this.setSelectionRange(9999, 9999)\&quot; &quot;</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot;onkeyup=\&quot;this.form.submit()\&quot; /&gt; &quot;</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot;&lt;input type=\&quot;submit\&quot; value=\&quot;find\&quot; /&gt;&quot;</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot;&lt;/form&gt;&quot;</span></span></code></pre></div>
<p>The only interesting thing here is that I’ve include a bit of JavaScript to enable page updates while typing into the
find box. See the FindPage in action below:</p>
<figure>
<img src="../img/FindPage.png" alt="The FindPage" />
<figcaption aria-hidden="true">The FindPage</figcaption>
</figure>
<h2 id="provide-a-graph-view-of-pages-and-their-links">Provide a graph view of pages and their links</h2>
<p>So far I’ve just reimplemented stuff that was already there in the original WikiWiki. While toying around with my HsWiki I thought it might be a nice addition to have a graph representation of the site content.</p>
<p>As always I try to code as little as possible myself and get the hard work done by the experts. In this case I’m relying on my alltime favourite Graph rendering library <a href="https://graphviz.org/">GraphViz</a>. This time in it’s web assembly incarnation <a href="https://github.com/magjac/d3-graphviz">d3-graphviz</a>.</p>
<p>So again we’ll have a specific route:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>mkYesod <span class="st">&quot;HsWiki&quot;</span> [parseRoutes|</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>/actions/graph  GraphR    GET</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>|]</span></code></pre></div>
<p>And a corresponding route handler function:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | handler for GET /actions/graph</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ot">getGraphR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>getGraphR <span class="ot">=</span> <span class="kw">do</span>                                    </span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  path     <span class="ot">&lt;-</span> getDocumentRoot                     <span class="co">-- obtain document root folder</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  allPages <span class="ot">&lt;-</span> liftIO <span class="op">$</span> computeIndex path          <span class="co">-- compute list of all wiki pages</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  allRefs  <span class="ot">&lt;-</span> liftIO <span class="op">$</span> <span class="fu">mapM</span>                       <span class="co">-- compute list of all back references</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    (\p <span class="ot">-&gt;</span> computeBackRefs path p allPages)       </span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    allPages                                      <span class="co">-- for each file in allPages</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> buildGraphView <span class="op">$</span> <span class="fu">zip</span> allRefs allPages  <span class="co">-- return Html view for [([PageName], PageName)] graph</span></span></code></pre></div>
<p>Please note that this implementation has <span class="math inline">\(O(n^2)\)</span>. This is caused by relying on <code>computeBackrefs</code> this function traverses all files and is called once for each file by <code>mapM</code>.
Improving this is left as an exercise for the interested reader (all pull requests are welcome!</p>
<p>The actual Html rendering is a bit more involved as I have to integrate the JS code for d3-graphviz and also to render the GraphViz DOT graph representation:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | build view for GraphViz representation of wiki page structure</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="ot">buildGraphView ::</span> [([<span class="dt">PageName</span>], <span class="dt">PageName</span>)] <span class="ot">-&gt;</span> <span class="dt">Html</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>buildGraphView graph <span class="ot">=</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  toHtml</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    [ pageHeader <span class="dt">False</span>,</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>      menuBar <span class="st">&quot;&quot;</span>,</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>      renderMdToHtml <span class="st">&quot;# Site Map \n&quot;</span>,</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>      renderMdToHtml <span class="st">&quot;[View as List](/actions/toc) \n&quot;</span>,</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>      preGraph,                                         <span class="co">-- load wasm scripts, begin JS script</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>      preEscapedToHtml <span class="op">$</span> renderNodes <span class="op">$</span> allNodes graph,  <span class="co">-- build list of all PageName nodes</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>      preEscapedToHtml <span class="op">$</span> renderGraph graph,             <span class="co">-- build link structure as directed graph</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>      postGraph,                                        <span class="co">-- render DOT digraph</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>      pageFooter</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- | render graph in DOT syntax (from -&gt; to;)</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="ot">renderGraph ::</span> [([<span class="dt">PageName</span>], <span class="dt">PageName</span>)] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>renderGraph graph <span class="ot">=</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldr</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    (\str <span class="ot">-&gt;</span> ((str <span class="op">++</span> <span class="st">&quot;,\n&quot;</span>) <span class="op">++</span>))</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;&quot;</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">concatMap</span> (\(sources, target) <span class="ot">-&gt;</span> </span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>      <span class="fu">map</span> </span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>        (\s <span class="ot">-&gt;</span> <span class="st">&quot;&#39;\&quot;&quot;</span> <span class="op">++</span> asString s <span class="op">++</span> <span class="st">&quot;\&quot; -&gt; \&quot;&quot;</span> <span class="op">++</span> asString target <span class="op">++</span> <span class="st">&quot;\&quot;;&#39;&quot;</span>) </span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>        sources) </span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>      graph)</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a><span class="co">-- | extract list of unique PageNames from graph</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a><span class="ot">allNodes ::</span> [([<span class="dt">PageName</span>], <span class="dt">PageName</span>)] <span class="ot">-&gt;</span> [<span class="dt">PageName</span>]</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>allNodes <span class="ot">=</span> nub <span class="op">.</span> (<span class="fu">uncurry</span> (<span class="fu">flip</span> (<span class="op">:</span>)) <span class="op">=&lt;&lt;</span>)</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a><span class="co">-- | render list of PageNames as DOT list of nodes with some nice formatting</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a><span class="ot">renderNodes ::</span> [<span class="dt">PageName</span> ] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>renderNodes <span class="ot">=</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">concatMap</span></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>    ( \n <span class="ot">-&gt;</span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;&#39;\&quot;&quot;</span> <span class="op">++</span> asString n</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a>          <span class="op">++</span> <span class="st">&quot;\&quot; [shape=\&quot;rect\&quot;, style=\&quot;rounded,filled\&quot;, fillcolor=\&quot;#f4f5f6\&quot;, fontcolor=\&quot;#9b4dca\&quot;, fontname=\&quot;Roboto\&quot;,  URL=\&quot;/&quot;</span></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>          <span class="op">++</span> asString n</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a>          <span class="op">++</span> <span class="st">&quot;\&quot;];&#39;, \n&quot;</span></span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Html with script code for loading d3-graphviz and opening the DOT digraph</span></span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a><span class="ot">preGraph ::</span> <span class="dt">Html</span></span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a>preGraph <span class="ot">=</span></span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a>  preEscapedToHtml <span class="op">$</span></span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;&lt;script src=\&quot;//d3js.org/d3.v5.min.js\&quot;&gt;&lt;/script&gt;&quot;</span></span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot;&lt;script src=\&quot;https://unpkg.com/@hpcc-js/wasm@0.3.11/dist/index.min.js\&quot;&gt;&lt;/script&gt;&quot;</span></span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot;&lt;script src=\&quot;https://unpkg.com/d3-graphviz@3.0.5/build/d3-graphviz.js\&quot;&gt;&lt;/script&gt;&quot;</span></span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot;&lt;div id=\&quot;graph\&quot; &gt;&lt;/div&gt;&quot;</span></span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot;&lt;script&gt;&quot;</span></span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot;var dot =\n&quot;</span></span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot;    [\n&quot;</span></span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot;        &#39;digraph  {&#39;,\n&quot;</span></span>
<span id="cb20-55"><a href="#cb20-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-56"><a href="#cb20-56" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Html with script code for rendering the DOT digraph</span></span>
<span id="cb20-57"><a href="#cb20-57" aria-hidden="true" tabindex="-1"></a><span class="ot">postGraph ::</span> <span class="dt">Html</span></span>
<span id="cb20-58"><a href="#cb20-58" aria-hidden="true" tabindex="-1"></a>postGraph <span class="ot">=</span></span>
<span id="cb20-59"><a href="#cb20-59" aria-hidden="true" tabindex="-1"></a>  preEscapedToHtml <span class="op">$</span></span>
<span id="cb20-60"><a href="#cb20-60" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;        &#39;}&#39;\n&quot;</span></span>
<span id="cb20-61"><a href="#cb20-61" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot;     ];\n&quot;</span></span>
<span id="cb20-62"><a href="#cb20-62" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot; \n&quot;</span></span>
<span id="cb20-63"><a href="#cb20-63" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot; d3.select(\&quot;#graph\&quot;).graphviz()\n&quot;</span></span>
<span id="cb20-64"><a href="#cb20-64" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot;     .renderDot(dot.join(&#39;&#39;));\n&quot;</span></span>
<span id="cb20-65"><a href="#cb20-65" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot; \n&quot;</span></span>
<span id="cb20-66"><a href="#cb20-66" aria-hidden="true" tabindex="-1"></a>      <span class="op">++</span> <span class="st">&quot; &lt;/script&gt;\n&quot;</span></span></code></pre></div>
<p>You can see this in action in the following screen shot:</p>
<figure>
<img src="../img/SiteMap.png" alt="The SiteMap with a graph rendering of pages and their links" />
<figcaption aria-hidden="true">The SiteMap with a graph rendering of pages and their links</figcaption>
</figure>
<h2 id="appendix">Appendix</h2>
<h3 id="how-to-build">How to build</h3>
<pre><code>stack init
stack install
HsWiki</code></pre>
<h3 id="installation-under-windows">Installation under Windows</h3>
<p>Under Windows you will have to install the ICU library. I used the latest win64 version from https://github.com/unicode-org/icu/releases/tag/release-70-1. You’ll have to manually copy <em>.ddl and </em>.h files to the following locations:</p>
<ul>
<li>The actual lib files go to <code>C:\Users\&lt;username&gt;\AppData\Local\Programs\stack\x86_64-windows\msys2-&lt;installdate&gt;\mingw64\lib</code>
Don’t forget to strip version number from the .dll files (so icuuc70.dll becomes icuuc.dll)</li>
<li>The include files go to <code>C:\Users\&lt;username&gt;\AppData\Local\Programs\stack\x86_64-windows\msys2-&lt;installdate&gt;\mingw64\include\unicode</code></li>
</ul>
]]></description>
    <pubDate>Sun, 09 Jan 2022 00:00:00 UT</pubDate>
    <guid>https://thma.github.io//posts/2022-01-09-Writing-a-Wiki-Server-with-Yesod.html</guid>
    <dc:creator>Thomas Mahler</dc:creator>
</item>

    </channel>
</rss>
